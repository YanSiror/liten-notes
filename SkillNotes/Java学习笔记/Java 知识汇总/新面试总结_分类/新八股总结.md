## Redis

> Redis 是基于键值对的非关系型数据库。Redis 拥有string、hash、list、set、zset等多种数据结构, redis具有惊人的读写性能, 其优秀的持久化机制是的它在断电和机械故障时也不会发生数据丢失, 可以用于热点数据存放, 还提供了键过期、发布订阅、食物、流水线、LUA脚本等多个高级功能。

### 1 Redis 数据结构

- `string`: 最基本数据类型, 可以存放入二进制、序列化数据、JSON对象、图片等数据

  - 底层实现: `SDS(Simple Dynamic String) - 动态字符串 `

    可修改字符串, 采用预分配冗余空间的方式减少内存的频繁分配。与Java中的ArrayList比较类似, 实质上也是在空间不足时触发扩容机制, 如果 SDS 值大小< 1M , 则增加一倍；反之如果>1M , 则当前空间加1M作为新的空间。

    <img src="imgs/654033f8e1b493432bee3543d2af8dbc-16932970960013.png" alt="在这里插入图片描述" style="zoom:50%;" />

    ```java
    struct sdshdr{
    	//记录buf数组中已使用字节的数量//等于SDS保存字符串的长度4byte
        int len;
    	//记录 buf数组中未使用字节的数量 4 byte
        int free;
    	//字节数组，用于保存字符串字节\0结尾的字符串占用了1byte
        char buf[];
    }
    ```

- `list`:   字符串列表, 按照插入的顺序排序, 元素可以重复, 底层由 `链表` 实现。

  - 底层实现: `ZIPList| LinkedList(双向链表)` 

    当元素字符串的长度小于64字节而且元素个数小于512时，采用 zipList；否则采用likedList；

    - `ZIPList - 压缩列表`: 由连续内存块组成且用于存储小型有序集合或哈希集合的数据结构。主要参数包括: 整个列表占用字节数、偏移量、元素个数、内容列表、结束标志。 **优点: 节省空间**

      <img src="imgs/8b092e16d4504bb4a5c42b8fe2c04e46tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-16932970979244.jpg" alt="image.png" style="zoom:50%;" />

      ```c++
      struct ziplist<T> {
          int32 zlbytes; // 整个压缩列表占用字节数
          int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
          int16 zllength; // 元素个数
          T[] entries; // 元素内容列表，挨个挨个紧凑存储
          int8 zlend; // 标志压缩列表的结束，值恒为 0xFF
      }
      ```

- `hash`:   string 类型 field 和 value 的集合, 适合存放对象

  - 底层实现: `ZIPList | HashTable` 

    当hash对象的键与值的长度都小于64字节时而且键值对的个数小于512个，采用zipList，其它情况，采用hashTable

    - `ZIPLIST: 参考上述`

    - `HashTable - 哈希表`

      ① 数组 + 链表  ②数组+红黑树(树化方便查找)

      <img src="imgs/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NkZmdlZ2VmZGc=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom:50%;" />

      根据Key value而直接进行访问的数据结构。它通过**把关键码值映射到表中一个位置来访问记录**（类似索引），以加快查找的速度。这个映射函数叫做**散列函数**，存放记录的数组叫做散列表。

- `set`:    无序不重复的集合

  - 底层实现: `INTSet | HashTable`

    当保存的元素都是整形数字，而且元素个数小于配置范围的时候，则使用intset，否则使用hash表。

    - `INTSet - 整数集合`

      可变长度的整型数组 - 基于整数数组来实现，并且具备长度可变、有序等特征, 包含: 编码方式、长度、内容等主要属性(可以选择不同位数的整数存储)。

      <img src="imgs/723e89ef8e9542c6a098ea7460e91877.png" alt="在这里插入图片描述" style="zoom:67%;" />

      ```c
      typedef struct intset {
          uint32_t encoding; /* 编码方式，支持存放16位、32位、64位整数 */
          uint32_t length;  /* 元素个数 */
          int8_t contents[];  /* 整数数组，保存集合数据 */
      } intset;
      ```

- `zset`:   与 set 一样都是 String 类型元素的集合, 且不允许重复, 但 zset 每个元素都会关联一个分数, Redis通过分数来为集合汇总的成员进行从小到大的排序。

  - 底层实现: `ZIPList| SKIPList`

    - `ZIPList: 参考上述`

    - `SKIPList`: 

      一种有序的数据结构，通过在每个节点维护多个指针，从而达到快速访问的目的。 **优点: 实现简单、内存消耗少** **缺点: 不适合范围查询**

      <img src="imgs/9c092a10e6fa4da0ae3bd2ea036fa7a7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.jpg" alt="image.png" style="zoom:50%;" />

      跳跃表 - 跳跃表节点结构定义

      ```c
      typedef struct zskiplist{
          // 表头节点和表尾节点
          struct zskiplist *header,*tail;
          // 表节点个数
          unsigned long length;
          // 表节点最大层数
          int level;
      }zskiplist；
      ```

      ```c
      typedef struct zskiplistNode{
           // 层
          struct zskiplistLevel{
              // 前进指针
              struct zskiplistNode *forward;
              // 跨度
              unsigned int span;
              
          }level[];
          // 后退指针
          struct zskiplistNode *backward;
          // 分值
          double score;
          // 成员对象
          robj *robj;
      }zskiplistNode;
      ```

- 四种特殊数据类型: 1）bitmap 2）hyperloglog 3）geo 4）stream



#### 1) zset 与 set 的区别

- set 无序, zset 有序

- zset 底层使用压缩列表和跳跃列表( ziplist & skiplist )

  set 使用 INTSet 和 HashTable



### 2 Key 过期策略

- `定期删除 ` - `过期 Key 保存在字典, 定期随机抽取20个Key, 删除其中过期的, 如果比例超过1/4, 重复删除步骤。`

  redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。

  Redis 默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。

  1.从过期字典中随机 20 个 key；

  2.删除这 20 个 key 中已经过期的 key；

  3.如果过期的 key 比率超过 1/4，那就重复步骤 1；

  redis默认是每隔 100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。

- `惰性删除` - `访问时发现 Key 过期, 直接删除不返回任何值`

  在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。

  定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，即当你主动去查过期的key时,如果发现key过期了,就立即进行删除,不返回任何东西。



### 3 内存淘汰策略

> 数据的淘汰策略: 当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。

- noeviction:      不淘汰任何key，但是内存满时不允许写入新数据，默认策略。

- volatile-TTL:    对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰。

- allkeys -RANDOM: 对全体key，随机进行淘汰。
- volatile-RANDOM: 对设置了TTL的key，随机进行淘汰。
- alkeys  -LRU:    对全体key，基于LRU算法进行淘汰
- volatile-LRU:    对设置了TTL的key，基于LRU算法进行淘汰

- allkeys -LFU:    对全体key，基于LFU算法进行淘汰

- volatile-LFU:    对设置了TTL的key，基于LFU算法进行淘汰



### 4 主从同步机制

- 主从同步

  - 全量同步

    一般发生在第一次连接时, 原理为将当前数据写入到RDB文件后发送给从机读取到丛机的内存中。

  - 增量同步

    一般发生在第一次之后的链接时, 主机同步期间发生的数据变化会以命令的形式写入缓存中, 当校验到正确的从机ID时获取从机的偏移量,然后从偏移量记录的命令开始将未同步的数据操作命令发送给从机执行, 进而完成数据同步。



### 5 Redis 分布式锁

1. 使用 SETNX（SET if Not eXists）指令：通过在 Redis 中设置一个特定的键值对来表示锁的状态。使用 SETNX 指令可以确保只有一个客户端能够成功设置该键，其他客户端会得到失败的返回值。通过设置适当的超时时间，可以避免锁被永久占用。

   ```redis
   SETNX lock_key 1
   ```

   上述代码中，如果返回值为 1，则表示获取到了锁；如果返回值为 0，则表示锁已经被其他客户端占用。

2. 使用 SET 指令结合 EX（过期时间）参数：类似于上述方法，但在设置锁时，同时设置一个适当的过期时间。这样即使锁没有被主动释放，也能保证一段时间后自动释放，避免死锁。

   ```
   SET lock_key 1 EX 10 NX
   ```

   上述代码中，锁的过期时间被设置为 10 秒，10 秒后锁会自动释放。

3. 使用 Redlock 算法：Redlock 算法是一个多实例下的分布式锁算法。它通过在多个 Redis 实例上设置锁，并使用时钟同步来保证锁的可靠性。Redlock 算法的实现相对复杂，需要确保不同实例之间的时钟同步性和对锁的正确使用。

**问题**

- 确保锁的唯一性：使用一个全局唯一的键来表示锁，避免不同客户端之间的冲突。
- 避免死锁：设置适当的超时时间或过期时间，确保即使锁没有被主动释放，也能够自动释放。
- 处理异常情况：在获取锁和释放锁的过程中，需要处理异常情况，确保锁的正常使用。
- 考虑锁的可重入性：根据具体需求，决定是否支持同一个客户端多次获取同一把锁。





## 计算机网络

### 1 OSI 七层模型 | TCP与UDP | 响应状态码

- OSI 模型

  <img src="imgs/v2-1578921092d775e024345fa8a531a85e_b.webp" alt="img" style="zoom: 67%;" />

  - 应用层: 计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。

    `HTTP` `SMTP` `FTP` `DNS`

  - 表示层: 负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。

  - 会话层: 建立和管理应用程序之间的通信。 ``

  - 传输层: 监控数据传输服务的质量，保证报文的正确传输。  `报文`  `TCP | UDP`

  - 网络层: 通过路由选择算法，为报文通过通信子网选择最适当的路径。 `数据报` `IP | ICMP | ARP | RARP`

  - 数据链路层: 过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。 `帧` `MAC`

  - 物理层: 解决硬件通信的问题 `比特`

- **TCP**

  基于连接, 提供可靠传输, 适合对网络通讯要求高的场景, 如: 传输文件、发送邮件、浏览网页等。

- **UDP**

  非连接, 提供不可靠交付, 适合网络通讯要求弱的场景, 如: 视频、语音、直播等

- **响应状态码**

  `200`  请求成功

  `404`  请求资源不存在

  `401`  未验证, 需要进行身份验证

  `500`  服务器错误, 无法完成请求(参数错误、请求方式错误无法响应)

  



### 2 HTTP 请求的过程 | HTTP 与 HTTPS 的区别

- **流程**

  1. 浏览器根据域名解析IP地址(DNS 解析)
  2. 浏览器与服务器建立 TCP 链接(三次握手: 确保双方都同意链接, 防止失效的请求再次发送到服务器)
  3. 浏览器与服务器建立 HTTP 链接
  4. 服务器响应请求, 返回 Response
  5. 浏览器解析 Response 并请求资源
  6. 结束关闭 TCP 链接, 浏览器展示页面(四次挥手: 确保正确的关闭 TCP 链接, 保证数据完整性和可靠性)

- **HTTP 与 HTTPS 的区别**

  HTTP与HTTPS都是位于应用层的数据传输协议, 它们最大的区别在于 HTTPS 对数据的安全性给予保障。

  - 安全性

    HTTP 明文传输未经过加密, 不需要使用证书; HTTPS 使用 SSL | TLS 协议进行加密, 通过证书授权来验证身份进而实现通信加密

  - 连接方式

    HTTP 是无状态协议, 服务端不保存请求信息; HTTPS 是基于安全连接的, 服务端会保存客户端的会话状态。



### 3 三次握手 | 四次挥手

- **三次握手**

  <img src="imgs/640.png" alt="图片" style="zoom:50%;" />

  客户端向服务端发送 SYN 包, 如果服务端同意返回 SYN+ACK 确认, 客户端收到后再发送 ACK , 服务端收到后即可建立连接。

  `举例`: A 与 B 隔着墙丢沙包, A说: "你可以听到我说话吗?"; B说: "可以听到"; A再说: "那我开始丢沙包了"

  - **问题**

    **1) 为什么不能两次握手?**

    ​	`为了防止已经失效的请求再次请求服务器` - 客户端挂掉的请求再次发送, 会导致服务端陷入长等待。

    `	为了确定双方都具有收发信息的能力`

    **2) 可以四次握手吗?**

    ​	理论上是可以的, 但是三次握手就可以确保双方都拥有收发信息的能力, 4次多余了一次做了无用功。

- **四次挥手**

  <img src="imgs/640-16922603973363.png" alt="图片" style="zoom:50%;" />

  已经传输数据完毕的客户端和服务端断开连接时, 客户端发送 FIN 报文标识要关闭连接, 服务端收到后发送 ACK 报文询问是否关闭并进入关闭等待状态(资源整理关闭的时间), 在处理等待完之后再次发送 FIN 字段标志服务端已经准备好关闭了, 此时客户端发送确认到服务端, 服务端关闭服务, 客户端进入超时等待。

  `举例`: A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

- **问题**

  **1) 为什么不可以三次挥手?**

  ​	三次挥手一般指的是将服务端发送 ACK+FIN 报文的过程合并为一次, 这时服务端就无法保证服务端数据是否发送完毕。  `与下面的问题等价↓`

  **2) 为什么连接的时候是三次握手，关闭的时候却是四次握手？**

  ​	在建立连接时服务端收到客户端的SYN连接报文后, 服务端发送SYN用于同步, ACK报文用于应答, 这时并没有数据处理过程自然也不需要等待。但是关闭连接时服务端收到FIN报文时, 很可能还需要发送数据, 这时服务端就会先发送 ACK 报文应答, 然后等待服务端数据发送完毕再发送FIN字段标志发送完毕。

  **3) 为什么客户端要等待超时时间 2MSL？**

  ​	①保证客户端发送的最后一个ACK报文段能够到达服务器。 ②防止已经失效的连接请求报文段出现在本连接中(客户端在发送完最后一个ACK报文段后，再经过时间2MSL。就可以使本连接持续的时间内所产生的所有报文段都在网络中消失。这样就可以在下一个新的连接中不会出现这种旧的连接请求报文段)。



### 4 JWT 为什么比 cookie 和 session 安全

- `Cookie`

  是以键值对的形式储存在浏览器中，而且在浏览器中可以直接看到数据。

  - 优点：
    1. 结构简单。cookie是一种基于文本的轻量结构，包含简单的键值对。
    2. 数据持久。虽然客户端计算机上cookie的持续时间取决于客户端上的cookie过期处理和用户干预，cookie通常是客户端上持续时间最长的数据保留形式。

  - 缺点：
    1. 大小受到限制。大多数浏览器对 cookie 的大小有 4096 字节的限制，尽管在当今新的浏览器和客户端设备版本中，支持 8192 字节的 cookie 大小已愈发常见。
    2. 非常不安全。cookie将数据裸露在浏览器中，这样大大增大了数据被盗取的风险，所有我们不应该将中要的数据放在cookie中，或者将数据加密处理。
    3. 容易被csrf攻击。可以设置csrf_token来避免攻击。

- `Session`

  session 存储在服务器中，然后发送一个cookie存储在浏览器中，cookie中存储的是session_id，之后每次请求服务器通过session_id可以获取对应的session信息

  - 优点：
    1. session的信息存储在服务端，相比于cookie就在一定程度上加大了数据的安全性；相比于jwt方便进行管理，也就是说当用户登录和主动注销，只需要添加删除对应的session就可以，这样管理起来很方便。

  - 缺点：
    1. session存储在服务端，这就增大了服务器的开销，当用户多的情况下，服务器性能会大大降低。
    2. 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。
    3. 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，会限制负载均衡和集群水平拓展的能力。

- `JWT`

  JWT 存储在浏览器的 storage 或者 cookie 中。由服务器产生加密的json数据包括：header，payload和signature三部分组成。header中通常来说由token的生成算法和类型组成；payload中则用来保存相关的状态信息；signature 部分由 header，payload，secret_key 三部分加密生成。 注意，不要在 JWT 的 payload 或 header 中放置敏感信息，除非它们是加密的。

  - 优点：
    1. 因为json的通用性，jwt可以支持跨语言请求，像JAVA,JavaScript,PHP等很多语言都可以使用。
    2. 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
    3. 便于传输，JWT的构成非常简单，字节占用很小，所以它是非常便于传输的。
    4. 不需要在服务端保存会话信息, 利于服务器横向拓展。

  - 缺点：
    1. 登录状态信息续签问题。比如设置token的有效期为一个小时，那么一个小时后，如果用户仍然在这个web应用上，这个时候当然不能指望用户再登录一次。目前可用的解决办法是在每次用户发出请求都返回一个新的token，前端再用这个新的token来替代旧的，这样每一次请求都会刷新token的有效期。但是这样，需要频繁的生成token。另外一种方案是判断还有多久这个token会过期，在token快要过期时，返回一个新的token。
    2. 用户主动注销。JWT并不支持用户主动退出登录，客户端在别处使用token仍然可以正常访问。为了支持注销，我的解决方案是在注销时将该token加入到服务器的redis黑名单中。

 

### 5 I/O 通信模型

Socket 是一种网络通信的编程接口，它提供了一种机制，使得不同计算机上的程序可以通过网络进行通信。以下的 BIO、AIO、NIO 都是 Socket 通信模型的一种。

- BIO - Blocked IO(阻塞IO)。 当用户线程发送请求后会一直阻塞线程直到数据准备完毕。 `同步IO`

- NIO - Nonblocking IO(非阻塞IO)。用户进程发送请求后可做其他工作并不断访问内核数据, 但在数据复制阶段, 用户线程依旧阻塞。 `同步IO`

- AIO - Asynchronous IO(异步IO) 。当用户线程发送请求后, 内核返回回调函数, 该回调函数不包含数据, 用户线程可以处理其他操作, 当数据准备完成后内核将数据发送给用户线程, 而不像同步IO那样由用户线程自己读取。

- IO 多路复用: 单个线程同时处理多个客户端请求。基于 `select`、`poll`、`epoll`三个操作。`select`: 查询多少个文件描述符需要IO, 底层为数组, 因此文件描述符个数有上限。 `poll`: 与select基本一致, 底层为链表, 因此文件描述符个数没有上限。 `epoll`: 更高效, 使用红黑树+链表。

  `poll` 和 `select` 都为轮询方式, 区别在于 `poll` 使用了链表, 因此文件描述符没有上限; `epoll` 则采用回调方式, 它将文件描述符加入到红黑书中, 当每个IO就绪之后直接返回数据, 而不需要多次复制操作。

- Java NIO: 同步非阻塞IO, 





## 操作系统

### 1 用户态和内核态

- `用户态 `   User Mode

  运行用户程序, 只能执行一些非特权指令。

- `内核态 `   Kernel Mode

  运行操作系统程序，操作硬件, 能够执行特权指令, 调用IO设备。

- `区别`

  处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的; 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占。





## 设计模式

### 1 单例模式 | 工厂模式 | 策略模式 | 观察者模式

#### 1) **单例模式**

分为饿汉式和懒汉式单例模式

- 饿汉式模式

  在类加载时就创建实例并初始化

  ```java
  public class Singleton(){
      private Singleton(){};
      private static Singleton instance = new Singleton1();
  	private static Singleton getInstance()
      {
          return single;
      }
  }
  ```

- 懒汉式模式

  在类加载时创建实例但不初始化, 只有在用时才初始化。

  ```java
  public class Singleton(){
      private static Singleton instance;
      private Singleton(){};
  	private static synchronized Singleton getInstance()
      {
     		if(instance == null){
              instance = new Singleton();
          }     
          return instance;
      }
  }
  ```



#### 2) **工厂模式**

分为简单工厂、工厂方法、抽象工厂

- 简单工厂

  提供一个统一的工厂类对实现了同一接口的一些类进行实例的创建。如 Animal 生产 Dog、Cat等多个动物。 

  ```java
  interface Sender {
      void Send();
  }
  
  class MailSender implements Sender {
  
      @Override
      public void Send() {
          System.out.println("This is mail sender...");
      }
  }
  
  class SmsSender implements Sender {
  
      @Override
      public void Send() {
          System.out.println("This is sms sender...");
      }
  }
  
  public class FactoryPattern {
      public static void main(String[] args) {
          Sender sender = produce("mail");
          sender.Send();
      }
      public static Sender produce(String str) {
          if ("mail".equals(str)) {
              return new MailSender();
          } else if ("sms".equals(str)) {
              return new SmsSender();
          } else {
              System.out.println("输入错误...");
              return null;
          }
      }
  }
  ```

- 工厂方法

  针对不同的对象提供不同的工厂。如 Animal 分配 DogFactory、CatFactory 生产不同的动物。

- 抽象工厂

  针对不同维度(多个品牌的手机、电脑)的产品提供总的接口, 用于创建不同维度的工厂, 而不需要指定具体类。如: Animal 分为 DogFactory 和 CatFactory, Dog 和 Cat 又分为不同品种, 这时再细分具体的如 OneDog | TwoDog 继承自 DogFactory 实现自己所需的方法。

  工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要扩展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？
  那么这就用到了抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。

  ```java
  interface Provider {
      Sender produce();
  }
  
  interface Sender {
      void Send();
  }
  
  class MailSender implements Sender {
  
      public void Send() {
          System.out.println("This is mail sender...");
      }
  }
  
  class SmsSender implements Sender {
  
      public void Send() {
          System.out.println("This is sms sender...");
      }
  }
  
  class SendMailFactory implements Provider {
  
      public Sender produce() {
          return new MailSender();
      }
  }
  
  class SendSmsFactory implements Provider {
  
      public Sender produce() {
          return new SmsSender();
      }
  }
  
  
  public class FactoryPattern {
      public static void main(String[] args) {
          Provider provider = new SendMailFactory();
          Sender sender = provider.produce();
          sender.Send();
      }
  }
  
  ```

  

#### 3) **策略模式**

> 概念: 策略设计模式是一种行为设计模式。*当在处理一个业务时，有多种处理方式，并且需要再运行时决定使哪一种具体实现时，就会使用策略模式。*
>
> **策略模式本质是**：`分离算法，选择实现`
>
> 通俗来讲：策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。
>
> **策略模式的宗旨** 就是将各项方法之间连接起来，达到一个新的方法，微服务的宗旨也是防止服务的多次调用，降低代码的耦合度，因此这么看来策略模式和微服务还是比较相像的。

策略模式:

```java
public interface PaymentStrategy {
    public void payment(BigDecimal amount);
}

public class CreditPaymentStrategy implements PaymentStrategy{
    @Override
    public void payment(BigDecimal amount) {
        System.out.println("使用银行卡支付" + amount);
        // 去调用网联接口
    }
}

public class WechatPaymentStrategy implements PaymentStrategy{
    @Override
    public void payment(BigDecimal amount) {
        System.out.println("使用微信支付" + amount);
        // 调用微信支付API
    }
}

public class AlipayPaymentStrategy implements PaymentStrategy {
    @Override
    public void payment(BigDecimal amount) {
        System.out.println("使用支付宝支付" + amount);
        // 调用支付宝支付API
    }
}

public class PaymentService {
    /**
    * 将strategy作为参数传递给支付服务
    */
    public void payment(PaymentStrategy strategy, BigDecimal amount) {
        strategy.payment(amount);
    }
}


public class StrategyTest {
    public static void main(String[] args) {
        PaymentService paymentService = new PaymentService();
        // 使用微信支付
        paymentService.payment(new WechatPaymentStrategy(), new BigDecimal("100"));
        //使用支付宝支付
        paymentService.payment(new AlipayPaymentStrategy(), new BigDecimal("100"));
    }
}
```

**总结**: 策略模式主要是在需要提供多种业务处理逻辑时, 提供任选的接口, 在拓展是只需要扩展新类即可, 而不需要修改原有的类, 满足开闭原则; 遇到工厂模式需要分类处理(if-else)的时候, 增加功能会违反 `开闭原则` , 策略模式则不会。 [Link1](https://www.cnblogs.com/ysocean/p/15635852.html) [Link2](https://mp.weixin.qq.com/s?__biz=MzIwNjg4MzY4NA==&mid=2247507414&idx=2&sn=ee20414b9c8bcfc2505c3a0110e2e583&chksm=971843dda06fcacba299e137e869496e0503bdba9841114f134736eb92fc4afe0a8cccae3e65&scene=21#wechat_redirect) [Link3](https://juejin.cn/post/7030976391596212255)



- JDK中使用策略模式的例子

  在JDK中最经典的使用策略模式的例子就是`Collections.sort(List<T> list, Comparator<? super T> c)`方法，这个方法接受一个比较器`Compartor`参数，客户端在运行时可以传入一个比较器的实现，`sort()`方法中根据不同实现，按照不同的方式进行排序。

- 策略模式使用场景

  在实际工作中，会有很多场景可以使用策略模式，比如上面例子中的多个支付方式，再比如与不同的第三方销售渠道对接等等。

  **总结一下**

  - 如果在一个系统里面有许多类，它们仅仅在行为上有区别，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为；
  - 一个系统需要动态地在几种算法中选择一种；
  - 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。



#### 4) 观察者模式

> 观察者模式又称为发布/订阅(Publish/Subscribe)模式,在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新(广播)。
>
> 在 `Java` 中，观察者模式通常由两个接口组成：`Subject` 和 `Observer`。`Subject`是被观察的对象，`Observer` 是观察者。`Subject` 接口定义了一系列方法，用于添加、删除和通知观察者，`Observer` 接口定义了一个 `update()` 方法，当 `Subject` 状态发生改变时，该方法被调用。

**实现**

在这个例子中，我们创建了一个`Subject`类，它包含一个列表`observers`，其中包含所有注册的观察者。`Subject`类还有一个状态`state`，它表示主题状态的变化。当状态改变时，`notifyAllObservers()`方法被调用，通知所有观察者更新它们的状态。

我们还创建了三个具体的观察者：`BinaryObserver`，`OctalObserver`和`HexaObserver`。每个观察者都需要一个`Subject`对象，并注册自己到该对象中。当`Subject`状态改变时，每个观察者都会收到通知并更新自己的状态，其中`update()`方法用于更新观察者状态。在`ObserverPatternDemo`类中，我们创建一个`Subject`对象，并向其注册三个观察者。然后，我们对主题进行两次状态更改，并在控制台输出每个观察者的状态。

@: `抽象类 Observer 与主题类 Subject, 实际观察者 A B C 分别继承抽象类。抽象类包含主题, 主题类包含观察者数组。在实际观察值设定主体的同时会把自身传递到主题类的观察者数组中, 这时就能够实现广播 - 调用更新。`

```java
import java.util.ArrayList;
import java.util.List;

public class Subject {
    private List<Observer> observers = new ArrayList<Observer>();
    private int state;

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
        notifyAllObservers();
    }

    public void attach(Observer observer){
        observers.add(observer);
    }

    public void notifyAllObservers(){
        for (Observer observer : observers) {
            observer.update();
        }
    }
}

public abstract class Observer {
    protected Subject subject;
    public abstract void update();
}

public class BinaryObserver extends Observer{

    public BinaryObserver(Subject subject){
        this.subject = subject;
        this.subject.attach(this);
    }

    public void update() {
        System.out.println( "Binary String: " + Integer.toBinaryString( subject.getState() ) );
    }
}

public class OctalObserver extends Observer{

    public OctalObserver(Subject subject){
        this.subject = subject;
        this.subject.attach(this);
    }

    public void update() {
        System.out.println( "Octal String: " + Integer.toOctalString( subject.getState() ) );
    }
}

public class HexaObserver extends Observer{

    public HexaObserver(Subject subject){
        this.subject = subject;
        this.subject.attach(this);
    }

    public void update() {
        System.out.println( "Hex String: " + Integer.toHexString( subject.getState() ).toUpperCase() );
    }
}

public class ObserverPatternDemo {
    public static void main(String[] args) {
        Subject subject = new Subject();

        new HexaObserver(subject);
        new OctalObserver(subject);
        new BinaryObserver(subject);

        System.out.println("First state change: 15");	
        subject.setState(15);
        System.out.println("Second state change: 10");	
        subject.setState(10);
    }
}
```

**OUT**

```cmd
First state change: 15
Hex String: F
Octal String: 17
Binary String: 1111
Second state change: 10
Hex String: A
Octal String: 12
Binary String: 1010
```

- **优点**
  1. 降低耦合性：观察者模式将主题（`Subject`）和观察者（`Observer`）之间的依赖关系解耦，使得它们可以独立地改变。主题不需要知道哪些观察者正在观察它，观察者也不需要知道主题的细节。
  2. 易于扩展：由于观察者模式是松散耦合的，因此可以很容易地添加或删除观察者，而不会影响主题或其他观察者。这使得代码更加灵活，易于扩展。
  3. 实现了开放/封闭原则：观察者模式遵循开放/封闭原则，即对于扩展是开放的，对于修改是封闭的。这意味着可以通过添加新的观察者来扩展系统的功能，而不必更改现有代码。
  4. 实现了可重用性：观察者模式将主题和观察者分离，使它们可以独立地进行测试和重用。
  5. 提高了灵活性和可维护性：观察者模式使得系统中的对象之间的通信变得更加灵活和可维护。它还使代码更易于理解和维护。
- **缺点**
  1. 内存泄漏：在观察者模式中，观察者需要注册到主题对象，当观察者不再需要时，需要从主题中注销，否则会导致内存泄漏。因为如果观察者对象没有被注销，则主题对象将保留对它的引用，这将防止观察者被垃圾回收。
  2. 性能问题：观察者模式在一些情况下可能会导致性能问题。当主题对象有大量观察者时，每当主题状态发生变化时，所有观察者都会被通知，这可能会导致性能问题。
  3. 并发问题：如果多个线程同时访问主题对象，并且主题对象在处理一个观察者时状态发生了变化，则可能会导致并发问题。因此，在使用观察者模式时需要小心处理并发问题。
  4. 对象的生命周期问题：观察者模式中的主题对象和观察者对象之间可能存在生命周期的问题。如果观察者对象在主题对象的生命周期内保持活动状态，这可能会导致一些不必要的问题



#### 5) 代理模式

- 静态代理

  `为其它所有对象编写代理类, 提供一种代理以控制对这个对象的访问(可以增强代码) - 外包 | 中介`

  假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。

  首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。

  ```php
  /** * 创建Person接口
   * @author Gonjan
   */public interface Person {    
       //上交班费    
       void giveMoney();
   }
  ```

  Student类实现Person接口。Student可以具体实施上交班费的动作。

  ```java
  public class Student implements Person {    
      private String name;    
      public Student(String name) {        
          this.name = name;    
      }
      @Override    
      public void giveMoney() {       
          System.out.println(name + "上交班费50元");    
      }
  }
  ```

  StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。

  ```java
  /** * 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为
   * @author Gonjan
   *
   */public class StudentsProxy implements Person{    
       //被代理的学生    
       Student stu;
      public StudentsProxy(Person stu) {        
          // 只代理学生对象        
          if(stu.getClass() == Student.class) {            
              this.stu = (Student)stu;        
          }    
      }
      //代理上交班费，调用被代理学生的上交班费行为    
       public void giveMoney() {        
           stu.giveMoney();    
       }
   }
  ```

  下面测试一下，看如何使用代理模式：

  ```cpp
  public class StaticProxyTest {    
      public static void main(String[] args) {        
          //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成        
          Person zhangsan = new Student("张三");
              //生成代理对象，并将张三传给代理对象        
          Person monitor = new StudentsProxy(zhangsan);
              //班长代理上交班费        
          monitor.giveMoney();    
  	}
  } 
  ```

- 动态代理

  不事先为每个需要代理的类写代理类, 而是在运行时动态的创建对应的代理类。实质上也就是通过反射技术, 在运行时判断是否需要代理, 如果需要代理的就使用反射获取对应的类再加以控制。



## 数据库

### 1 数据库引擎 innodb 和 myisam 的区别

- **innodb**: 支持事务、默认行级锁、删改性能更优、`innodb 聚簇与非聚簇索引都有 `

  支持MySQL事务，具有提交，回滚和崩溃恢复功能能够更加安全的保护用户数据；支持行级锁，提高多用户并发和性能；支持外键，维护数据完整性。

- **myisam**: 不支持事务、默认表级锁、查询性能更优、`MyisAM 引擎没有聚簇索引`。

  占用空间较小，支持表级锁，能够限制读写工作的负载的性能，查询效率较高，常用于只读场景。



### 2 聚簇与非聚簇索引

- **聚簇索引**

  找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。

- **非聚簇索引**

  索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询, 非聚簇索引也叫做辅助索引。

- **区别**

  索引与数据是否放在一起。 聚簇 - 在一起; 非聚簇 - 不在一起

  主键一定是聚簇索引, 其它普通索引需要区分SQL场景，当SQL查询的列就是索引本身时，我们称这种场景下该普通索引也可以叫做聚簇索引。



### 3 事务隔离级别 | 事务的 ACID 特性

- 问题
  - 脏读: 一个事务读取了另一个事务未提交的数据
  - 不可重复读: 事务两次读取的数据不一致  - 数据不一致
  - 幻读: 事务两次读取数据库，两次查询结果的条数不同 - 数目不一致
- 事务隔离级别
  - 读未提交: 一个事务可以读到其他事物未提交的数据 
  - 读已提交: 一个事务可以读到其它事务提交的数据  避免 `脏读`
  - 可重复读: 一个事务两次读取到的数据相同  避免 `脏读` `不可重复读`
  - 串行化: 读取时加共享锁, 修改时加排它锁,效率最低。  避免 `脏读` `不可重复读` `幻读`
- ACID 特性
  - A(Atomicity - 原子性): 事务要么做要么不做
  - C(Consistency - 一致性): 事务执行的结果必须是使数据库从一个一致性状态变成另一个一致性状态
  - I(Isolation - 隔离性): 事务的执行不能干扰其他事务
  - D(Durability - 持续性): 事务一旦完成，对数据库的修改是永久的



### 4 MVCC 特性

*背*: `MVCC 是数据库中一种多版本并发控制逻辑。它会对每个事务设定一个版本号也即事务id, 通过隐藏字段存储。这时根据当前操作事务的id 与 ReadView 中的 m_ids(活跃事务ID)的最小值和最大值进行比较, 如果小于最小值则可见, 大于则不可见, 在此中间则根据当前事务ID是否位于m_ids中以及是否等于创建该ReadView的id判断, 如果不位于m_ids中或等于creator_id则可见, 其余不可见。然后根据ReadView的结果, 得到结果。`

> **Multi-Version Concurrency Control （多版本并发控制）**: 一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。MySQL 数据库管理系统使用的一种并发控制机制，它允许多个事务同时读取数据库中的数据，而不会出现读写冲突。
>
> 通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。数据库隔离级别**读已提交、可重复读** 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。   [Link](https://juejin.cn/post/7016165148020703246#heading-30)

- 关键点

  - 事务版本号: 事务开启前, 都会获取一个自增长的事务ID, 根据ID判断事务执行先后顺序。

  - 隐式字段: 对于InnoDB存储引擎，每一行记录都有两个隐藏列**trx_id**、**roll_pointer**，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列**row_id**。

    | 列名         | 是否必须 | 描述                                             |
    | ------------ | -------- | ------------------------------------------------ |
    | row_id       | 否       | 单调递增的行ID，不是必需的，占用6个字节。        |
    | trx_id       | 是       | 记录操作该数据事务的事务ID                       |
    | roll_pointer | 是       | 这个隐藏列就相当于一个指针，指向回滚段的undo日志 |

  - undo log: **回滚日志**，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。

    可以这样认为，当delete一条记录时，undo log 中会记录一条对应的insert记录，当update一条记录时，它记录一条对应相反的update记录。

    undo log 用途？

    1. 事务回滚时，保证原子性和一致性。
    2. 用于MVCC快照读。

  - 版本链: 多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为**版本链**。(实质上就是多个事务执行事务完成后得到的不同版本随机链接起来)

  - 快照读: 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读,如：

    ```sql
    select * from core_user where id > 2;
    ```

  - 当前读: 读取的是记录数据的最新版本，显式加锁的都是当前读

    ```csharp
    select * from core_user where id > 2 for update;
    select * from account where id>2 lock in share mode;
    ```

  - Read View

    事务执行SQL语句时，产生的读视图。实质上就是根据:

      m_ids:当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。

      min_limit_id:表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。

      max_limit_id:表示生成ReadView时，系统中应该分配给下一个事务的id值。

      creator_trx_id: 创建当前read view的事务ID

    *判断当前事务 trx_id 是否在 ReadView 之前|之后完成, 则可见|不可见。在两者中间根据情况讨论。*

    **Read view 匹配条件规则**:

    1. 如果数据事务ID `trx_id < min_limit_id`，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。
    2. 如果`trx_id>= max_limit_id`，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。
    3. 如果 `min_limit_id =<trx_id< max_limit_id`,需腰分3种情况讨论

    - 如果`m_ids`包含`trx_id`,则代表Read View生成时刻，这个事务还未提交，但是如果数据的`trx_id`等于`creator_trx_id`的话，表明数据是自己生成的，因此是**可见**的。
    - 如果`m_ids`包含`trx_id`，并且`trx_id`不等于`creator_trx_id`，则 ReadView生成时，事务未提交，并且不是自己生产的，所以当前事务也是**看不见**的；
    - 如果`m_ids`不包含`trx_id`，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。

- 原理分析

  - 查询一条记录，基于MVCC，是怎样的流程

    1. 获取事务自己的版本号，即事务ID
    2. 获取Read View
    3. 查询得到的数据，然后Read View中的事务版本号进行比较。
    4. 如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;
    5. 最后返回符合规则的数据

    InnoDB 实现MVCC，是通过` Read View+ Undo Log` 实现的，Undo Log 保存了历史快照，Read View可见性规则帮助判断当前版本的数据是否可见。

  - 当一个事务对数据库进行修改时，MySQL不会直接修改原始数据，而是将其标记为删除，并创建一个新版本的数据。新版本的数据会被加上新的创建时间和事务ID。

  - 当一个事务查询数据时，MySQL会根据该事务ID和创建时间来确定该事务能够看到哪些数据版本。如果该事务的开始时间早于某个数据版本的创建时间，则该事务不能看到该数据版本。

  - 当一个事务提交时，MySQL会将该事务的所有修改操作应用到数据库中，并将其事务ID与当前时间一起记录在数据库的undo日志中，用于回滚操作。

**MVCC 机制的好处是可以允许并发的读取和写入，提高数据库的并发性能。同时，MVCC也提供了高度的隔离性，保证了事务之间的数据不会相互影响。**



### 5 MySQL 加锁方式

在MySQL中，可以通过使用锁来控制并发访问数据库的行为。MySQL支持多种类型的锁，包括行级锁和表级锁。以下是MySQL中常用的加锁方式：

- 行级锁

  行级锁可以在MySQL中使用SELECT ... FOR UPDATE语句进行加锁。该语句会在查询时对选中的行进行加锁，防止其他事务同时对同一行进行修改。例如：

  ```
  SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
  ```

  该语句会将id为1的行加上行级锁，直到当前事务提交或回滚之前，其他事务无法对该行进行修改。

- 表级锁

  表级锁可以在MySQL中使用LOCK TABLES语句进行加锁。该语句会将整个表加上锁，防止其他事务对该表进行修改。例如：

  ```
  LOCK TABLES table_name WRITE;
  ```

  该语句将table_name表加上写锁，其他事务无法对该表进行写操作，直到当前事务提交或回滚之后，锁才会释放。



### 6 



## Java SE

### 1 接口与抽象类的区别

- 接口

  使用 `Interface` 关键字修饰

  支持多继承, 一个接口可以继承多个接口, 一个类可以实现多个接口

  接口只能有定义, 不能有方法的实现

  接口可以包含变量、方法

  接口变量默认为 `public static final`, 必须赋初值, 不能被修改

  **需要实现统一的行为接口**

- 抽象类

  使用 `abstract` 关键字修饰

  不能被实例化只能被继承

  包含抽象方法的一定是抽象类, 抽象类不一定有抽象方法

  可以有方法的定义和实现

  抽象类可以包含属性、方法、构造方法

  抽象类变量默认`default`, 可在子类中重新定义, 也可被重新赋值

  **在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。**

- 相同点

  不能被实例化; 继承抽象类和实现接口的子类都要实现声明的抽象方法



### 2 Java 常见加密解密算法

- `Base64`

  用 64 个可打印字符来表示二进制数据。这 64 个字符是：小写字母 a-z、大写字母 A-Z、数字 0-9、符号"+"、"/"（再加上作为垫字的"="，实际上是 65 个字符），其他所有符号都转换成这个字符集中的字符。Base64 编码通常用作存储、传输一些二进制数据编码方法，所以说它本质上是一种将二进制数据转成文本数据的方案。

- `哈希加密`

  - MD5（Message Digest Algorithm 5）

    MD5 主要用做数据一致性验证、数字签名和安全访问认证，而不是用作加密。比如说用户在某个网站注册账户时，输入的密码一般经过 MD5 编码，更安全的做法还会加一层盐（salt），这样密码就具有不可逆性。然后把编码后的密码存入数据库，下次登录的时候把密码 MD5 编码，然后和数据库中的作对比，这样就提升了用户账户的安全性。生成128位散列值，常用于校验数据完整性。   `单向加密算法，只能加密不能解密`

  - bcrypt

    bcrypt 是一种自带盐值（自动加盐）的加密方案。 

    *加密* : 随机生成 salt -> salt; 跟 password 进行 hash

    *解密* : 从 hash 中取出salt -> salt跟 password 进行hash计算 -> 将得到的hash跟数据库中提取的的hash进行比对返回Boolean类型：true/false

    |    **项**    |                           **md5**                            |                          **bcrypt**                          |
    | :----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
    | **密文长度** |                             32位                             |                             60位                             |
    |  **安全性**  | 安全性差。密码相同时，加密后密文一样。提升安全性的方案：加密前生成随机的盐值（字符串），将它与密码拼接，然后再使用md5加密。 | 安全性好。密码相同时，生成的密文是不一样的。（因为它自动生成随机盐值） |
    | **加密耗时** |                              短                              |                             略长                             |

  - SHA（Secure Hash Algorithm - 安全散列算法）

    FIPS所认证的安全散列算法。能计算出一个数字消息所对应的长度固定字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。数字签名等密码学应用中重要的工具，被广泛地应用于电子商务等信息安全领域。 SHA-1、SHA-256、SHA-512 等散列算法，生成不同长度的散列值。

- `非对称加密`

  - RSA（Rivest-Shamir-Adleman）

    非对称加密算法，用于实现公钥加密和数字签名。RSA使用公钥进行加密，私钥进行解密或签名。生成密钥对、公开公钥、公钥加密私钥解密、私钥加密公钥解密。

  - DSA（Digital Signature Algorithm）

    数字签名算法，用于生成和验证数字签名。

- `对称加密`

  - AES（Advanced Encryption Standard）

    目前最常用的对称加密算法之一，支持 128 位、192 位和 256 位密钥长度。密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。简单说就是 DES 的增强版，比 DES 的加密强度更高。

  - DES（Data Encryption Standard）

     DES 是一种对称加密算法，所谓对称加密算法就是：加密和解密使用相同密钥的算法。DES 加密算法出自 IBM 的研究，后来被美国政府正式采用，之后开始广泛流传。但近些年使用越来越少，因为 DES 使用 56 位密钥，以现代的计算能力，24 小时内即可被破解。

  - 3DES（Triple Data Encryption Algorithm）

    对DES进行了三重加密，提供更高的安全性。

- `对称加密和非对称加密的区别`

  对称加密：

  - 使用相同的密钥进行加密和解密操作，因此也称为共享密钥加密。
  - 加密速度较快，适合处理大量数据。
  - 密钥管理相对简单，只需保护好密钥的安全性。
  - 主要用于数据加密和解密，不适用于身份验证和数字签名。
  - 常见的对称加密算法有AES、DES、3DES等。

  非对称加密：

  - 使用一对密钥，即公钥和私钥，进行加密和解密操作，因此也称为公钥加密。
  - 公钥用于加密数据，私钥用于解密数据，公钥可以公开分发，私钥保密。
  - 加密速度较慢，适合处理较小的数据量。
  - 可用于身份验证、数字签名和密钥交换等场景。
  - 常见的非对称加密算法有RSA、DSA等。

  对称加密和非对称加密的主要区别如下：

  - 密钥数量：对称加密使用相同的密钥进行加密和解密，而非对称加密使用一对不同的密钥。
  - 加密速度：对称加密算法加密和解密速度较快，而非对称加密算法加密和解密速度较慢。
  - 安全性：对称加密的主要安全性依赖于密钥的保护，而非对称加密的安全性依赖于私钥的保密性。
  - 用途：对称加密主要用于数据加密和解密，而非对称加密可以用于身份验证、数字签名和密钥交换等场景。

  



## JUC

### 1 Java 常用的锁和原理

`Synchronized` 和 `Lock` 

- **Synchronized**

  `关键字`; `synchronized 可以自动释放`; `synchronized 不可以判断加锁状态`

  synchronize 的用法及原理:

  synchronized 可以修饰静态方法、代码块、普通方法。它能够保证同一时间只有一个线程执行该代码, 保证线程安全。它能够在执行完毕或出现异常后自动释放锁。底层是采用Java对象头来存储锁信息的,并且还支持锁升级。在JVM里的实现都是 基于进入和退出 Monitor 对象来实现方法同步和代码块同步。synchronized 加在普通方法上, 锁当前实例; 加在静态方法, 锁当前类的从class对象;加在代码块上, 则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。

- **Lock**

  `接口`; `Lock 加锁不会自动释放`; `Lock 可以通过 tryLock() 判断加锁状态`;

  



### 2 volatile 的用法及原理

`volatile 是一个Java的关键字，用来解决内存可见性问题的。它能够保证线程之间可见, 通过添加屏障的方式避免指令重排序导致的线程安全问题。`

- 保证线程之间的可见性

  volatile 关闭 JIT(即时编译器) 对其所修饰变量的优化(多线程并发的情况下, JIT 优化有时候会导致非预期的结果)

- 禁止指令重排序

  volatile 禁止指令重排序(添加屏障)

  写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下
  读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上

  volatile使用技巧:

  - 写变量让 volatile 修饰的变量的在代码最后位置
  - 读变量让 volatile 修饰的变量的在代码最开始位置



### 3 Sychronized 锁升级

`无锁 ----> 偏向锁 ----> 轻量级锁 ----> 重量级锁`   锁升级是不可逆的，只能升级不能降级

- `无锁`

  不添加锁

- `偏向锁`

  **为什么引入**: 解决只有一个线程执行同步代码时提高性能。

  **升级过程**: 就是在锁对象的对象头中有个 `ThreadId` 字段, 这个字段如果是空的，线程第一次获取锁的时候，就将线程自身的 `ThreadId` 写入到锁的 `ThreadId` 字段内，将锁头内的是否偏向锁的状态位置 1。这样下次获取锁的时候，直接检查ThreadId是否和自身线程Id一致，如果一致，则认为当前线程已经获取了锁，因此不需再次获取锁，略过了轻量级锁和重量级锁的加锁阶段。

  **撤销过程**: 只有当其他线程竞争该锁时，持有偏向锁的线程才会被撤销，释放该偏向锁。并且撤销需要等待全局安全点，也就是该时间点没有字节码正在执行。

  **作用**: 当一段同步代码一直被同一个线程多次访问时，由于只有一个线程，该线程后续访问时无需再次获取锁。  -  性能高

- `轻量级锁`

  轻量级锁，偏向锁是单线程下的锁优化，这个就说多线程下的锁优化了，当有多个 线程竞争同一个临界资源，这个时候偏向锁就会被撤（这个步骤也是十分消耗资源的），然后升级为轻量级锁，这个也是一个基于 CAS 的乐观锁。

  **为什么引入 | 作用**: `在线程近乎交替执行同步代码时提高性能`。轻量级锁是为了在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统的 Mutex Lock 带来的性能消耗，轻量级锁适用于线程交替执行同步代码的场景。所以轻量级锁是为了在线程近乎交替执行同步代码时提高性能。

  **升级过程**: *线程 A 与 线程 B 同时抢占锁对象时，偏向锁会被撤销并将锁升级为轻量级锁。*线程 A 在执行同步代码前，JVM 在线程的栈帧中创建用于存储锁记录的空间 Lock Record。当线程 A 抢占锁对象时，JVM 使用 CAS 操作将锁对象的对象头的 Mark Word 拷贝进线程 A 的锁记录 Lock Record 中（这个拷贝 Mark Word 的过程官方称为 `Displaced Mark Word`），并且将 Mark Word 中指向线程栈中 Lock Record 的指针指向线程 A 的锁空间。如果更新成功，则线程 A 持有该对象锁，并将对象锁的 Mark Word 的锁标志位更新为 00。即此时线程 A 持有轻量级锁会执行同步代码，而线程 B 会自旋等待获取该轻量级锁；如果更新失败，则说明该锁被线程 B 抢占。

  **撤销过程**: 1. 当有两个以上的线程同时竞争一个锁时，那么轻量级锁会被撤销并升级为重量级锁，不再通过自旋的方式等待获取锁而是直接阻塞线程；

  ​		  2. 当持有轻量级锁的线程执行完同步代码时，同样会释放轻量级锁，会使用 CAS 操作将锁对象的 Mark Word 中指针指向的锁记录 Lock Record 重新替换回锁对象的 Mark Word。

- `重量级锁`

  当存在两个以上的线程竞争同一把锁或线程竞争轻量级锁自旋多次仍然失败时，会导致锁升级为重量级锁。重量级锁会直接阻塞持有锁的线程以外的所有线程，防止 CPU 空转，减小 CPU 的开销。通过将锁对象的 Mark Word 的锁标志位更新为 10，从而将锁升级为重量级锁。此时可以看到 Mark Word 中有一个指向互斥量的指针，这个指针其实指向的就是 Monitor 对象的起始地址，通过 Monitor 对象即可实现互斥访问同步代码，也就是通过阻塞唤醒的方式实现同步。

- `锁自旋`

  锁自旋，什么是锁自旋呢，很简单就是线程自己做一些无用功，避免线程被挂起阻塞 ，它自己在哪里做一些空任务，然后去竞争锁，避免被挂起阻塞（阻塞和唤醒是又是十分消耗性能的行为，这边涉及到用户态和核心态的操作系统问题，一般我们操作的都是用户态，但是线程的挂起阻塞是需要从用户态切换到核心态，同样，线程唤醒也一样，这个步骤会造成巨大的性能消耗，能避免尽量避免）。当然，锁自旋也是会消耗一定的 CPU 的。

- 总结

  以上就是 synchronized 的锁升级内容了，JDK 1.6 之后采用锁升级的方式来优化 synchronized 同步锁，提高了程序的运行效率。接下来总结一下偏向锁、轻量级锁、重量级锁三者的优缺点以及使用场景。

  |  锁类型  |                             优点                             |                             缺点                             |
  | :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
  |  偏向锁  | `只有一个线程`访问同步代码时，只在置换ThreadID时进行一次CAS操作，锁的开销低，性能接近于无锁状态。 | 线程间存在竞争时，需要频繁暂停持有锁的线程并检查状态和撤销锁，反而带来额外的开销。 |
  | 轻量级锁 | (`两个线程`)线程间存在交替竞争时，竞争的线程不需要阻塞，提高了响应速度。 | 当大量线程存在竞争时，线程始终的抢占不到锁，会导致CPU空转消耗CPU性能。 |
  | 重量级锁 | `(多个线程竞争一个)`通过阻塞唤醒的方式实现同步，防止CPU空转，不会消耗CPU性能。 | 线程阻塞导致响应时间变长，频繁切换CPU状态，导致性能消耗增大。 |

  根据三类锁的优缺点可以知道使用场景：

  - 偏向锁：**适用于单线程的情况**，在不存在锁竞争的时候进入同步代码可以使用偏向锁。
  - 轻量级锁：**适用于竞争较不激烈且同步代码执行时间较短的情况**，存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁要更高效。
  - 重量级锁：**适用于竞争激烈且同步代码执行时间较长的情况**，此时使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。



### 4 公平锁和非公平锁

- 公平锁

  所有线程按申请顺序获得锁, 队列第一个才可以获得锁。

  - 优点：所有的线程都能得到资源，不会饿死在队列中。
  - 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

- 非公平锁

  所有线程获取锁先尝试, 没有的话才等待, 否则直接拿到锁。

  - 优点：可以减少 CPU 唤醒线程的开销，整体的吞吐效率会高点，CPU 也不必取唤醒所有线程，会减少唤起线程的数量。
  - 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

- Lock实现公平锁与非公平锁方法

  ReentrantLock 的构造函数可以传入一个boolean参数，用于控制锁的公平性, 如下所示

  ```java
  public ReentrantLock() {
      sync = new NonfairSync();
  }
  public ReentrantLock(boolean fair) {
      sync = fair ? new FairSync() : new NonfairSync();
  }
  ```

  公平锁会有 `hasQueuedPredecessors` 方法判断该线程是否位于队列头部, 只有在队列头部的线程才能获得锁。



### 5 JUC | CAS | AQS

`JUC(java.util.concurrent)` 包含多个支持并发操作的工具, 是Java支持并发操作的核心, 包括线程操作、线程池、并发容器、原子操作的具体实现。

- 原子类: 遵循 CAS(比较和替换)原则, 可用于解决单个变量的线程安全问题。
- 锁: 在包含 Synchronized 所有功能基础上, 支持超时和响应中断机制, 主要解决多个变量的线程安全问题。
- 线程池: 可以方便的管理线程, 避免重复开关线程导致的消耗。
- 并发容器: 例如ConcurrentHashMap，支持多线程操作的并发集合，效率更快。 

`CAS(Compare And Swap - 比较和替换)`

- CAS的全称是 Compare-and-Swap，也就是比较并交换，是并发编程中一种常用的算法。

  它包含了三个参数：V，A，B。其中，V表示要读写的内存位置，A表示旧的预期值，B表示新值。

  `CAS` 的核心思想是：在执行操作之前，先比较当前内存中的值是否等于期望值，如果相等，则执行修改操作；如果不相等，则不执行修改操作，继续进行比较，直到内存中的值与期望值相等为止。这个过程中不会出现线程的阻塞和唤醒，因此可以提高系统的并发性能。 CAS 操作需要输人两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。

`AQS (Abstract Queued Synchronizer - 队列同步器)`

- **概念**: 用来构建锁和同步器的框架, 用于实现锁和其他同步组件和维护共享资源, 使用队列让线程进行排队的过程, Lock 基于其实现。

- **理解**: `AQS` 通过一个 `FIFO` 队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制。

- **原理**: AQS 维护了一个 `valatile int state` 变量和 `CLH 虚拟双向队列`(即不存在队列实例，仅存在节点之间的关联关系), 队列中的节点持有线程引用，每个节点均可通过`getState()`、`setState()`和`compareAndSetState()`对`state`进行修改和访问。当线程获取锁时，即试图对`state`变量做修改，如修改成功则获取锁；如修改失败则包装为节点挂载到队列中，等待持有锁的线程释放锁并唤醒队列中的节点。

  <img src="imgs/e22dfb7003ee44afb6f80ddfbce68a93tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="img" style="zoom:50%;" />



### 6 分布式锁

> 当多个进程不在同一个系统中，用于控制多个进程对资源访问的锁



### 7 线程池核心参数 | 扩容与缩容策略

- **线程池核心参数**

  `corePoolSize`	线程池核心线程大小

  `maximumPoolSize` 线程池最大线程数量

  `keepAliveTime`  线程存活时间

  `unit`		  存活时间单位

  `workQueue`	 工作队列 - 4种: 基于数组、链表、不缓存、优先级的有界阻塞队列

  <img src="imgs/image-20230901192712408.png" alt="image-20230901192712408" style="zoom:50%;" />

  `threadFactory`  线程工厂 - 创建线程用的工厂, 指定线程名等

  `handler`       拒绝策略

- **扩容与缩容策略**

  线程池的扩容和缩容操作可以通过调整核心线程数和最大线程数来实现：

  - 扩容：当提交的任务数量超过核心线程数且工作队列已满时，线程池会创建新的线程来处理任务，直到达到最大线程数。可以通过适当增大核心线程数和最大线程数来提高线程池的并发能力。
  - 缩容：线程池中的线程在空闲一定时间后会被销毁，以减少资源消耗。可以通过设置合适的线程存活时间来控制线程的缩容。





## JVM

### 1 Java 内存模型 | JVM 内存模型

- Java 内存模型

  Java 内存模型是一种规范, 定义了Java程序中多线程并发访问共享内存时的行为和准则, 旨在提供一种统一的内存访问模型, 使得开发者能够编写正确、可靠而高效的多线程程序。

- JVM 内存模型

  指JVM对内存的组织和管理方式, JVM 内存模型定义了Java程序在运行时的内存结构, 包括堆、栈、方法区等。JVM内存模型规定了Java程序运行时的内存分配、使用和回收方式, 以及线程与内存的交互方式。

  主要由以下5个部分组成(运行时数据区):

  **堆**: 用于存储对象实例和数组, 是线程共享的内存区域。

  **栈**: 每个线程都有自己的栈, 用于存储方法调用、局部变量和操作数栈。

  **方法区**: 存储类的结构信息、静态变量、常量池等

  **程序计数器**: 记录当前线程执行的字节码指令地址

  **本地方法栈**: 用于执行本地方法的栈

- 特点

  - JVM 内存模型与硬件和操作系统的内存模型有一定的差异，JVM 可以在不同平台上实现统一的内存模型。
  - JVM 通过即时编译器（Just-in-Time Compiler，JIT）等技术进行代码优化和内存管理。
  - JVM 内存模型规定了对象的创建、访问、修改和销毁的方式，以及垃圾回收机制对内存的管理。



### 2 JVM 分代回收策略

Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代，这就是 JVM 的内存分代策略。注意: 在 HotSpot 中除了新生代和老年代，还有永久代。



### 3 GC 可达性分析的根节点有哪些

在Java语言中，可以作为GCRoots的对象包括下面几种：

- 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI(Native方法)引用的对象。



### 4 垃圾回收器 | 垃圾回收算法

#### 1) 垃圾回收器（Garbage Collector - GC）：

垃圾回收器是JVM中负责执行垃圾回收的组件。JVM提供了不同类型的垃圾回收器，包括：

- Serial 收集器：单线程收集器，适用于小型应用和简单的客户端应用。
- Parallel 收集器：多线程收集器，适用于多核CPU上的应用，可以并行进行垃圾回收。
- **CMS（Concurrent Mark and Sweep）收集器**：并发标记和清除收集器，避免长时间的停顿时间。 `1.9 后停用`
  1. 初始标记: 对根节点与根节点有直接关系的对象进行可达性分析并标记。
  2. 并发标记: 根据根节点标记所有可达对象。
  3. 重新标记: 更新在并发标记阶段被复活的对象。
  4. 并发清除: 并发清除所有被标记为垃圾的对象并回收内存空间。
  5. 缺点: 会产生内存碎片
- **G1（Garbage-First）收集器**：分代收集器，将堆划分为多个区域，分别进行垃圾回收。`1.9 后成为默认的回收器`
  1. 初始标记: 暂停应用线程, 对根节点与根节点有直接关系的对象进行可达性分析并标记。
  2. 并发标记: 根据根节点标记所有可达对象。
  3. 最终标记: 标记之前遗漏的对象, 线程被暂停。
  4. 筛选回收: 根据每个区域内存活的对象数量, 根据回收目标选择需要回收的区域, 然后将选中区域对象复制到空闲区, 并清理回收区域(复制算法)。
  5. 特点: 分代回收: 划分为不同的区域(新生代、老年代、存活区等); 并发执行; 更适合处理大堆内存和具有并发行性质的应用程序, 特别适用于服务器应用, 提供良好的停顿时间和吞吐量。



#### 2) 垃圾回收算法

JVM 使用不同的垃圾回收算法来标记和回收垃圾对象。常见的垃圾回收算法包括：

- 标记-清除算法（Mark and Sweep）：标记所有活动对象，然后清除未标记的对象。	`优点：垃圾回收速度快。缺点：存在内存碎片`
- 标记-整理算法（Mark and Compact）：标记活动对象，然后将它们向一端移动，然后清除其余空间。 `优点：没有内存碎片。缺点：整理速度慢`
- 复制算法（Copying）：将存活对象复制到一个新的空间，并清除旧空间中的所有对象。  `优点：没有内存碎片。缺点：内存开销大`



## Spring

> Spring 是一个轻量级的免费框架，它有两大核心功能，分别是 IOC 和 AOP ，IOC 控制反转是将创建对象的权限交给 spring 框架来控制。可以很好的起到解耦的作用。AOP 是一种编程思想以及面向切面编程，底层使用的是动态代理。可以在程序原有的功能上进行增强，常用的场景有日志记录和权限验证。

### 1 IOC | AOP

- **IOC**(控制反转)

  IOC 控制反转主要是指将创建对象的权限交给spring，在之前创建对象时使用new关键字，而现在直接从spring框架中拿出已创建好的实例即可。Spring负责维护对象之间的依赖关系，降低对象之间的耦合度，它的实现方式为DI - 依赖注入 主要的注入方式包括: 构造器、setter、接口注入。

- **AOP**(面向切面编程)

  AOP 面向切面编程是spring的两大核心之一，它是一种编程思想。在方法上开一个切口，可以在这个类执行之前执行自定义的方法，在不修改源代码的前提下，对方法进行增强。它可以对业务逻辑的各个部分进行隔离，降低耦合, 提高代码的可重用性。它的底层是通过动态代理来实现的，它主要场景包括日志记录和权限验证。



### 2 BeanFactory 和 FactoryBean 的区别

BeanFactory 是最基础的IOC容器, 是一种规范模式; 而 FactoryBean 知识 SpringIOC 创建 Bean 的一种形式。

- beanfactory：是所有spring bean容器的顶级接口，是最基础的IOC容器，它为spring的容器定义了一套方法，并提供像getBean这样的方法从容器中获取指定的bean实例。它在产生bean的同时，还提供了解决bean之间的依赖注入的能力，也就是所谓的di。
- factory bean：工厂bean，只是SpringIOC容器创建Bean的一种形式，它是一个接口，它的主要功能是动态去生成某一类型的bean的一个实例，也就是说 我们可以自定义一个bean并且加载到ioc容器里面，getObject是用来实现动态构建bean的一个过程。







## 应用场景

### 1 全局主键生成策略

- `数据库自增序列`

- `UUID`

  **UUID由以下几部分的组合：**    `当前时间` + `时钟序列` + `机器码`
  （1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。
  （2）时钟序列。  *“uuid的随机组件”  随机序列, 避免因一些特殊情况导致的 id 重复问题*
  （3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。

  ```java
  UUID uuid = UUID.randomUUID();
  ```

  **优点：**
  1）使用简单。
  2）生成ID性能高，基本不会有性能问题。
  3）全球唯一，当数据迁移、数据合并、数据库变更时，可以从容应对。

  **缺点**：
  1）数据无序，无法保证趋势递增。
  2）UUID使用字符串存储，查询效率较低。（常见优化方案为“转化为两个uint64整数存储”或者“折半存储”，折半后不能保证唯一性）
  3）存储空间较大，如果是海量数据库，需考虑存储量的问题。
  4）传输数据量大。
  5）可读性差。

- `SnowFlake 算法`

  snowflake 是 Twitter开源的分布式ID生成算法，结果是一个long型的ID。   `时间戳` + `机器码` + `序列号`

  **其核心思想是：**

  - 最高位是符号位，始终为0，不可用。
  - 41 bit 作为毫秒数 - 41位的长度可以使用69年
  - 10 bit 作为机器编号 （5个bit是数据中心，5个bit的机器ID） - 10位的长度最多支持部署1024个节点
  - 12 bit 作为毫秒内序列号 - 12位的计数顺序号支持每个节点每毫秒产生4096个ID序号

  <img src="imgs/658190-20221011092259658-771095778.png" alt="image" style="zoom:50%;" />

  算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。

  snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。

  **优点：**

  - 不依赖于数据库，速度快，性能高。
  - ID 按照时间在单机上是递增的。
  - 可以根据实际情况调整各各位段，方便灵活。

  **缺点**：

  - 在单机上是递增的，由于涉及到分布式环境，每台机器上的时钟不可能完全同步，有时也会出现不是全局递增的情况。
  - 只能趋势递增。（如果绝对递增，竞对中午下单，第二天再下单即可大概判断该公司的订单量，危险！）
  - 依赖机器时间，如果发生回拨会导致可能生成id重复。









































