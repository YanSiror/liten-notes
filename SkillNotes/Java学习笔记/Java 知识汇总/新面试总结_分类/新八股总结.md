## Redis

> Redis 是基于键值对的非关系型数据库。Redis 拥有string、hash、list、set、zset等多种数据结构, redis具有惊人的读写性能, 其优秀的持久化机制是的它在断电和机械故障时也不会发生数据丢失, 可以用于热点数据存放, 还提供了键过期、发布订阅、食物、流水线、LUA脚本等多个高级功能。

### 1 Redis 数据结构

- `string`: 最基本数据类型, 可以存放入二进制、序列化数据、JSON对象、图片等数据 

  - 语法:

    ```redis
    set key value   //存储
    	set username super     
    get key			//获取
    	get username
    del key 		//删除
    	del username
    ```

    

  - 底层实现: `SDS(Simple Dynamic String) - 动态字符串 `

    可修改字符串, 采用预分配冗余空间的方式减少内存的频繁分配。与Java中的ArrayList比较类似, 实质上也是在空间不足时触发扩容机制, 如果 SDS 值大小< 1M , 则增加一倍；反之如果>1M , 则当前空间加1M作为新的空间。

    <img src="imgs/654033f8e1b493432bee3543d2af8dbc-16932970960013.png" alt="在这里插入图片描述" style="zoom:50%;" />

    ```java
    struct sdshdr{
    	//记录buf数组中已使用字节的数量//等于SDS保存字符串的长度4byte
        int len;
    	//记录 buf数组中未使用字节的数量 4 byte
        int free;
    	//字节数组，用于保存字符串字节\0结尾的字符串占用了1byte
        char buf[];
    }
    ```

- `list`:   字符串列表, 按照插入的顺序排序, 元素可以重复, 底层由 `链表` 实现。

  - 语法:

    ```redis
    lpush key value			//元素加入左列表
    	lpush username super
    rpush key value			//元素加入右列表
    	rpush username super
    lrange key start end		//范围获取
    	lrange person 0 -1			//获取全部
    lpop person				//删除列表最左边的元素，并将元素返回
    	lpop person
    rpop key				//删除列表最右边的元素，并将元素返回
    	rpop person
    ```

  - 底层实现: `ZIPList| LinkedList(双向链表)` 

    当元素字符串的长度小于64字节而且元素个数小于512时，采用 zipList；否则采用likedList；

    - `ZIPList - 压缩列表`: 由连续内存块组成且用于存储小型有序集合或哈希集合的数据结构。主要参数包括: 整个列表占用字节数、偏移量、元素个数、内容列表、结束标志。 **优点: 节省空间**

      <img src="imgs/8b092e16d4504bb4a5c42b8fe2c04e46tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-16932970979244.jpg" alt="image.png" style="zoom:50%;" />

      ```c++
      struct ziplist<T> {
          int32 zlbytes; // 整个压缩列表占用字节数
          int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
          int16 zllength; // 元素个数
          T[] entries; // 元素内容列表，挨个挨个紧凑存储
          int8 zlend; // 标志压缩列表的结束，值恒为 0xFF
      }
      ```

- `hash`:   string 类型 field 和 value 的集合, 适合存放对象

  - 语法:

    ```redis
    hset key field value 		//存储
    	hset person username super
    hget person username		//获取
    	hget person username
    hgetall key					//获取所有的key : value
    	hgetall person	
    hdel key field				//删除
    	hdel person username
    ```

  - 底层实现: `ZIPList | HashTable` 

    当hash对象的键与值的长度都小于64字节时而且键值对的个数小于512个，采用zipList，其它情况，采用hashTable

    - `ZIPLIST: 参考上述`

    - `HashTable - 哈希表`

      ① 数组 + 链表  ②数组+红黑树(树化方便查找)

      <img src="imgs/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NkZmdlZ2VmZGc=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom:50%;" />

      根据Key value而直接进行访问的数据结构。它通过**把关键码值映射到表中一个位置来访问记录**（类似索引），以加快查找的速度。这个映射函数叫做**散列函数**，存放记录的数组叫做散列表。

- `set`:    无序不重复的集合

  - 语法

    ```redis
    sadd key value		//存储
    	sadd person a
    smembers key 		/获取所有
    	smembers person
    srem key value		//删除元素
    	srem person a	
    ```

    

  - 底层实现: `INTSet | HashTable`

    当保存的元素都是整形数字，而且元素个数小于配置范围的时候，则使用intset，否则使用hash表。

    - `INTSet - 整数集合`

      可变长度的整型数组 - 基于整数数组来实现，并且具备长度可变、有序等特征, 包含: 编码方式、长度、内容等主要属性(可以选择不同位数的整数存储)。

      <img src="imgs/723e89ef8e9542c6a098ea7460e91877.png" alt="在这里插入图片描述" style="zoom:67%;" />

      ```c
      typedef struct intset {
          uint32_t encoding; /* 编码方式，支持存放16位、32位、64位整数 */
          uint32_t length;  /* 元素个数 */
          int8_t contents[];  /* 整数数组，保存集合数据 */
      } intset;
      ```

- `zset`:   与 set 一样都是 String 类型元素的集合, 且不允许重复, 但 zset 每个元素都会关联一个分数, Redis通过分数来为集合汇总的成员进行从小到大的排序。

  - 语法

    ```redis
    zadd key score value		//存储
    	zadd person 30 math
    zrange key start end		//获取
    	zrange person 0 -1   	 //获取所有
    zrem key value				//删除
    	zren person math	   
    ```

  - 底层实现: `ZIPList| SKIPList`

    - `ZIPList: 参考上述`

    - `SKIPList`: 

      一种有序的数据结构，通过在每个节点维护多个指针，从而达到快速访问的目的。 **优点: 实现简单、内存消耗少** **缺点: 不适合范围查询**

      <img src="imgs/9c092a10e6fa4da0ae3bd2ea036fa7a7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.jpg" alt="image.png" style="zoom:50%;" />

      跳跃表 - 跳跃表节点结构定义

      ```c
      typedef struct zskiplist{
          // 表头节点和表尾节点
          struct zskiplist *header,*tail;
          // 表节点个数
          unsigned long length;
          // 表节点最大层数
          int level;
      }zskiplist；
      ```

      ```c
      typedef struct zskiplistNode{
           // 层
          struct zskiplistLevel{
              // 前进指针
              struct zskiplistNode *forward;
              // 跨度
              unsigned int span;
              
          }level[];
          // 后退指针
          struct zskiplistNode *backward;
          // 分值
          double score;
          // 成员对象
          robj *robj;
      }zskiplistNode;
      ```

- 四种特殊数据类型: 1）bitmap 2）hyperloglog 3）geo 4）stream



#### 1) zset 与 set 的区别

- set 无序, zset 有序

- zset 底层使用压缩列表和跳跃列表( ziplist & skiplist )

  set 使用 INTSet 和 HashTable



### 2 Key 过期策略

- `定期删除 ` - `过期 Key 保存在字典, 定期随机抽取20个Key, 删除其中过期的, 如果比例超过1/4, 重复删除步骤。`

  redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。

  Redis 默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。

  1.从过期字典中随机 20 个 key；

  2.删除这 20 个 key 中已经过期的 key；

  3.如果过期的 key 比率超过 1/4，那就重复步骤 1；

  redis默认是每隔 100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。

- `惰性删除` - `访问时发现 Key 过期, 直接删除不返回任何值`

  在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。

  定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，即当你主动去查过期的key时,如果发现key过期了,就立即进行删除,不返回任何东西。



### 3 内存淘汰策略

> 数据的淘汰策略: 当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。

- noeviction:      不淘汰任何key，但是内存满时不允许写入新数据，默认策略。

- volatile-TTL:    对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰。

- allkeys -RANDOM: 对全体key，随机进行淘汰。
- volatile-RANDOM: 对设置了TTL的key，随机进行淘汰。
- alkeys  -LRU:    对全体key，基于LRU算法进行淘汰
- volatile-LRU:    对设置了TTL的key，基于LRU算法进行淘汰

- allkeys -LFU:    对全体key，基于LFU算法进行淘汰

- volatile-LFU:    对设置了TTL的key，基于LFU算法进行淘汰



### 4 主从同步机制

- 主从同步

  - 全量同步

    一般发生在第一次连接时, 原理为将当前数据写入到RDB文件后发送给从机读取到丛机的内存中。

  - 增量同步

    一般发生在第一次之后的链接时, 主机同步期间发生的数据变化会以命令的形式写入缓存中, 当校验到正确的从机ID时获取从机的偏移量,然后从偏移量记录的命令开始将未同步的数据操作命令发送给从机执行, 进而完成数据同步。



### 5 Redis 分布式锁

1. 使用 SETNX（SET if Not eXists）指令：通过在 Redis 中设置一个特定的键值对来表示锁的状态。使用 SETNX 指令可以确保只有一个客户端能够成功设置该键，其他客户端会得到失败的返回值。通过设置适当的超时时间，可以避免锁被永久占用。

   ```redis
   SETNX lock_key 1
   ```

   上述代码中，如果返回值为 1，则表示获取到了锁；如果返回值为 0，则表示锁已经被其他客户端占用。

2. 使用 SET 指令结合 EX（过期时间）参数：类似于上述方法，但在设置锁时，同时设置一个适当的过期时间。这样即使锁没有被主动释放，也能保证一段时间后自动释放，避免死锁。

   ```
   SET lock_key 1 EX 10 NX
   ```

   上述代码中，锁的过期时间被设置为 10 秒，10 秒后锁会自动释放。

3. 使用 Redlock 算法：Redlock 算法是一个多实例下的分布式锁算法。它通过在多个 Redis 实例上设置锁，并使用时钟同步来保证锁的可靠性。Redlock 算法的实现相对复杂，需要确保不同实例之间的时钟同步性和对锁的正确使用。

**问题**

- 确保锁的唯一性：使用一个全局唯一的键来表示锁，避免不同客户端之间的冲突。
- 避免死锁：设置适当的超时时间或过期时间，确保即使锁没有被主动释放，也能够自动释放。
- 处理异常情况：在获取锁和释放锁的过程中，需要处理异常情况，确保锁的正常使用。
- 考虑锁的可重入性：根据具体需求，决定是否支持同一个客户端多次获取同一把锁。



### 6 数据库与缓存一致性

四种同步策略: 

- 先更新数据库再更新缓存

  多线程并发会出现数据不一致情况

- 先更缓存再更数据库

  每次数据变化可以及时更新缓存, 但是消耗大、性能不高。

- 先删除缓存再更新数据库

  也可能导致数据不一致情况

- 先更新数据库再删除缓存

  也可能导致数据不一致情况, 最优方案: 出错时可以使用重试机制来异步重新处理。





## 计算机网络

### 1 OSI 七层模型 | TCP与UDP | 响应状态码

- OSI 模型

  <img src="imgs/v2-1578921092d775e024345fa8a531a85e_b.webp" alt="img" style="zoom: 67%;" />

  - 应用层: 计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。

    `HTTP` `SMTP` `FTP` `DNS`

  - 表示层: 负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。

  - 会话层: 建立和管理应用程序之间的通信。 ``

  - 传输层: 监控数据传输服务的质量，保证报文的正确传输。  `报文`  `TCP | UDP`

  - 网络层: 通过路由选择算法，为报文通过通信子网选择最适当的路径。 `数据报` `IP | ICMP | ARP | RARP`

  - 数据链路层: 过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。 `帧` `MAC`

  - 物理层: 解决硬件通信的问题 `比特`

- **TCP**

  基于连接, 提供可靠传输, 适合对网络通讯要求高的场景, 如: 传输文件、发送邮件、浏览网页等。

- **UDP**

  非连接, 提供不可靠交付, 适合网络通讯要求弱的场景, 如: 视频、语音、直播等

- **响应状态码**

  `200`  请求成功

  `400`  客户端请求报文中存在语法错误，服务器无法理解

  `401`  未验证, 需要进行身份验证

  `403`  服务器拒绝执行

  `404`  请求资源不存在
  
  `500`  服务器错误, 无法完成请求(参数错误、请求方式错误无法响应)
  
  



### 2 HTTP 请求的过程 | HTTP 与 HTTPS 的区别

- **流程**

  1. 浏览器根据域名解析IP地址(DNS 解析)
  2. 浏览器与服务器建立 TCP 链接(三次握手: 确保双方都同意链接, 防止失效的请求再次发送到服务器)
  3. 浏览器与服务器建立 HTTP 链接
  4. 服务器响应请求, 返回 Response
  5. 浏览器解析 Response 并请求资源
  6. 结束关闭 TCP 链接, 浏览器展示页面(四次挥手: 确保正确的关闭 TCP 链接, 保证数据完整性和可靠性)

- **HTTP 与 HTTPS 的区别**

  HTTP与HTTPS都是位于应用层的数据传输协议, 它们最大的区别在于 HTTPS 对数据的安全性给予保障。

  - 安全性

    HTTP 明文传输未经过加密, 不需要使用证书; HTTPS 使用 SSL | TLS 协议进行加密, 通过证书授权来验证身份进而实现通信加密

  - 连接方式

    HTTP 是无状态协议, 服务端不保存请求信息; HTTPS 是基于安全连接的, 服务端会保存客户端的会话状态。



### 3 三次握手 | 四次挥手

- **三次握手**

  <img src="imgs/640.png" alt="图片" style="zoom:50%;" />

  客户端向服务端发送 SYN 包, 如果服务端同意返回 SYN+ACK 确认, 客户端收到后再发送 ACK , 服务端收到后即可建立连接。

  `举例`: A 与 B 隔着墙丢沙包, A说: "你可以听到我说话吗?"; B说: "可以听到"; A再说: "那我开始丢沙包了"

  - **问题**

    **1) 为什么不能两次握手?**

    ​	`为了防止已经失效的请求再次请求服务器` - 客户端挂掉的请求再次发送, 会导致服务端陷入长等待。

    `	为了确定双方都具有收发信息的能力`

    **2) 可以四次握手吗?**

    ​	理论上是可以的, 但是三次握手就可以确保双方都拥有收发信息的能力, 4次多余了一次做了无用功。

- **四次挥手**

  <img src="imgs/640-16922603973363.png" alt="图片" style="zoom:50%;" />

  已经传输数据完毕的客户端和服务端断开连接时, 客户端发送 FIN 报文标识要关闭连接, 服务端收到后发送 ACK 报文询问是否关闭并进入关闭等待状态(资源整理关闭的时间), 在处理等待完之后再次发送 FIN 字段标志服务端已经准备好关闭了, 此时客户端发送确认到服务端, 服务端关闭服务, 客户端进入超时等待。

  `举例`: A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

- **问题**

  **1) 为什么不可以三次挥手?**

  ​	三次挥手一般指的是将服务端发送 ACK+FIN 报文的过程合并为一次, 这时服务端就无法保证服务端数据是否发送完毕。  `与下面的问题等价↓`

  **2) 为什么连接的时候是三次握手，关闭的时候却是四次握手？**

  ​	在建立连接时服务端收到客户端的SYN连接报文后, 服务端发送SYN用于同步, ACK报文用于应答, 这时并没有数据处理过程自然也不需要等待。但是关闭连接时服务端收到FIN报文时, 很可能还需要发送数据, 这时服务端就会先发送 ACK 报文应答, 然后等待服务端数据发送完毕再发送FIN字段标志发送完毕。

  **3) 为什么客户端要等待超时时间 2MSL？**

  ​	①保证客户端发送的最后一个ACK报文段能够到达服务器。 ②防止已经失效的连接请求报文段出现在本连接中(客户端在发送完最后一个ACK报文段后，再经过时间2MSL。就可以使本连接持续的时间内所产生的所有报文段都在网络中消失。这样就可以在下一个新的连接中不会出现这种旧的连接请求报文段)。



### 4 JWT 为什么比 cookie 和 session 安全

- `Cookie`

  是以键值对的形式储存在浏览器中，而且在浏览器中可以直接看到数据。

  - 优点：
    1. 结构简单。cookie是一种基于文本的轻量结构，包含简单的键值对。
    2. 数据持久。虽然客户端计算机上cookie的持续时间取决于客户端上的cookie过期处理和用户干预，cookie通常是客户端上持续时间最长的数据保留形式。

  - 缺点：
    1. 大小受到限制。大多数浏览器对 cookie 的大小有 4096 字节的限制，尽管在当今新的浏览器和客户端设备版本中，支持 8192 字节的 cookie 大小已愈发常见。
    2. 非常不安全。cookie将数据裸露在浏览器中，这样大大增大了数据被盗取的风险，所有我们不应该将中要的数据放在cookie中，或者将数据加密处理。
    3. 容易被csrf攻击。可以设置csrf_token来避免攻击。

- `Session`

  session 存储在服务器中，然后发送一个cookie存储在浏览器中，cookie中存储的是session_id，之后每次请求服务器通过session_id可以获取对应的session信息

  - 优点：
    1. session的信息存储在服务端，相比于cookie就在一定程度上加大了数据的安全性；相比于jwt方便进行管理，也就是说当用户登录和主动注销，只需要添加删除对应的session就可以，这样管理起来很方便。

  - 缺点：
    1. session存储在服务端，这就增大了服务器的开销，当用户多的情况下，服务器性能会大大降低。
    2. 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。
    3. 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，会限制负载均衡和集群水平拓展的能力。

- `JWT`

  JWT 存储在浏览器的 storage 或者 cookie 中。由服务器产生加密的json数据包括：header，payload和signature三部分组成。header中通常来说由token的生成算法和类型组成；payload中则用来保存相关的状态信息；signature 部分由 header，payload，secret_key 三部分加密生成。 注意，不要在 JWT 的 payload 或 header 中放置敏感信息，除非它们是加密的。

  - 优点：
    1. 因为json的通用性，jwt可以支持跨语言请求，像JAVA,JavaScript,PHP等很多语言都可以使用。
    2. 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
    3. 便于传输，JWT的构成非常简单，字节占用很小，所以它是非常便于传输的。
    4. 不需要在服务端保存会话信息, 利于服务器横向拓展。

  - 缺点：
    1. 登录状态信息续签问题。比如设置token的有效期为一个小时，那么一个小时后，如果用户仍然在这个web应用上，这个时候当然不能指望用户再登录一次。目前可用的解决办法是在每次用户发出请求都返回一个新的token，前端再用这个新的token来替代旧的，这样每一次请求都会刷新token的有效期。但是这样，需要频繁的生成token。另外一种方案是判断还有多久这个token会过期，在token快要过期时，返回一个新的token。
    2. 用户主动注销。JWT并不支持用户主动退出登录，客户端在别处使用token仍然可以正常访问。为了支持注销，我的解决方案是在注销时将该token加入到服务器的redis黑名单中。

 

### 5 I/O 通信模型

Socket 是一种网络通信的编程接口，它提供了一种机制，使得不同计算机上的程序可以通过网络进行通信。以下的 BIO、AIO、NIO 都是 Socket 通信模型的一种。

- BIO - Blocked IO(阻塞IO)。 当用户线程发送请求后会一直阻塞线程直到数据准备完毕。 `同步IO`

- NIO - Nonblocking IO(非阻塞IO)。用户进程发送请求后可做其他工作并不断访问内核数据, 但在数据复制阶段, 用户线程依旧阻塞。 `同步IO`

- AIO - Asynchronous IO(异步IO) 。当用户线程发送请求后, 内核返回回调函数, 该回调函数不包含数据, 用户线程可以处理其他操作, 当数据准备完成后内核将数据发送给用户线程, 而不像同步IO那样由用户线程自己读取。

- IO 多路复用: 单个线程同时处理多个客户端请求。基于 `select`、`poll`、`epoll`三个操作。`select`: 查询多少个文件描述符需要IO, 底层为数组, 因此文件描述符个数有上限。 `poll`: 与select基本一致, 底层为链表, 因此文件描述符个数没有上限。 `epoll`: 更高效, 使用红黑树+链表。

  `poll` 和 `select` 都为轮询方式, 区别在于 `poll` 使用了链表, 因此文件描述符没有上限; `epoll` 则采用回调方式, 它将文件描述符加入到红黑书中, 当每个IO就绪之后直接返回数据, 而不需要多次复制操作。

- Java NIO: 同步非阻塞IO, 





## 操作系统

### 1 用户态和内核态

- `用户态 `   User Mode

  运行用户程序, 只能执行一些非特权指令。

- `内核态 `   Kernel Mode

  运行操作系统程序，操作硬件, 能够执行特权指令, 调用IO设备。

- `区别`

  处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的; 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占。





### 2 进程与线程与协程 | 进程通信

- 进程通信

  管道: 管道本质是内核中维护的一块内存缓冲区;  信号量;  消息队列: 消息链表;  共享内存: 多个进程共享的内存; 套接字

- 进程-线程-协程

  - 进程: 操作系统的执行单元, 具有独立的内存空间和资源, 进程之间独立运行。

  - 线程: 进程内的一个执行单元, 共享进程的内存空间和资源, 多个线程可以并发执行。

  - 协程: 轻量级线程, 调度完全由用户控制, 因此也被称作用户级线程, 切换开销很小, 更适合高并发和IO密集型服务。

  - 区别: 

    线程 - 协程: 协程更加轻量, 并发性更好;进程和线程都可以拥有多个协程; 线程与进程都是同步机制, 协程是异步机制; 线程是抢占式的, 协程是非抢占式的, 因此需要用户主动释放



## 设计模式

### 1 单例模式 | 工厂模式 | 策略模式 | 观察者模式

#### 1) **单例模式**

分为饿汉式和懒汉式单例模式

- 饿汉式模式

  在类加载时就创建实例并初始化

  ```java
  public class Singleton(){
      private Singleton(){};
      private static Singleton instance = new Singleton1();
  	private static Singleton getInstance()
      {
          return single;
      }
  }
  ```

- 懒汉式模式

  在类加载时创建实例但不初始化, 只有在用时才初始化。

  ```java
  public class Singleton(){
      private static Singleton instance;
      private Singleton(){};
  	private static synchronized Singleton getInstance()
      {
     		if(instance == null){
              instance = new Singleton();
          }     
          return instance;
      }
  }
  ```



#### 2) **工厂模式**

分为简单工厂、工厂方法、抽象工厂

- 简单工厂

  提供一个统一的工厂类对实现了同一接口的一些类进行实例的创建。如 Animal 生产 Dog、Cat等多个动物。 

  ```java
  interface Sender {
      void Send();
  }
  
  class MailSender implements Sender {
  
      @Override
      public void Send() {
          System.out.println("This is mail sender...");
      }
  }
  
  class SmsSender implements Sender {
  
      @Override
      public void Send() {
          System.out.println("This is sms sender...");
      }
  }
  
  public class FactoryPattern {
      public static void main(String[] args) {
          Sender sender = produce("mail");
          sender.Send();
      }
      public static Sender produce(String str) {
          if ("mail".equals(str)) {
              return new MailSender();
          } else if ("sms".equals(str)) {
              return new SmsSender();
          } else {
              System.out.println("输入错误...");
              return null;
          }
      }
  }
  ```

- 工厂方法

  针对不同的对象提供不同的工厂。如 Animal 分配 DogFactory、CatFactory 生产不同的动物。

- 抽象工厂

  针对不同维度(多个品牌的手机、电脑)的产品提供总的接口, 用于创建不同维度的工厂, 而不需要指定具体类。如: Animal 分为 DogFactory 和 CatFactory, Dog 和 Cat 又分为不同品种, 这时再细分具体的如 OneDog | TwoDog 继承自 DogFactory 实现自己所需的方法。

  工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要扩展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？
  那么这就用到了抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。

  ```java
  interface Provider {
      Sender produce();
  }
  
  interface Sender {
      void Send();
  }
  
  class MailSender implements Sender {
  
      public void Send() {
          System.out.println("This is mail sender...");
      }
  }
  
  class SmsSender implements Sender {
  
      public void Send() {
          System.out.println("This is sms sender...");
      }
  }
  
  class SendMailFactory implements Provider {
  
      public Sender produce() {
          return new MailSender();
      }
  }
  
  class SendSmsFactory implements Provider {
  
      public Sender produce() {
          return new SmsSender();
      }
  }
  
  
  public class FactoryPattern {
      public static void main(String[] args) {
          Provider provider = new SendMailFactory();
          Sender sender = provider.produce();
          sender.Send();
      }
  }
  
  ```

  

#### 3) **策略模式**

> 概念: 策略设计模式是一种行为设计模式。*当在处理一个业务时，有多种处理方式，并且需要再运行时决定使哪一种具体实现时，就会使用策略模式。*
>
> **策略模式本质是**：`分离算法，选择实现`
>
> 通俗来讲：策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。
>
> **策略模式的宗旨** 就是将各项方法之间连接起来，达到一个新的方法，微服务的宗旨也是防止服务的多次调用，降低代码的耦合度，因此这么看来策略模式和微服务还是比较相像的。

策略模式:

```java
public interface PaymentStrategy {
    public void payment(BigDecimal amount);
}

public class CreditPaymentStrategy implements PaymentStrategy{
    @Override
    public void payment(BigDecimal amount) {
        System.out.println("使用银行卡支付" + amount);
        // 去调用网联接口
    }
}

public class WechatPaymentStrategy implements PaymentStrategy{
    @Override
    public void payment(BigDecimal amount) {
        System.out.println("使用微信支付" + amount);
        // 调用微信支付API
    }
}

public class AlipayPaymentStrategy implements PaymentStrategy {
    @Override
    public void payment(BigDecimal amount) {
        System.out.println("使用支付宝支付" + amount);
        // 调用支付宝支付API
    }
}

public class PaymentService {
    /**
    * 将strategy作为参数传递给支付服务
    */
    public void payment(PaymentStrategy strategy, BigDecimal amount) {
        strategy.payment(amount);
    }
}


public class StrategyTest {
    public static void main(String[] args) {
        PaymentService paymentService = new PaymentService();
        // 使用微信支付
        paymentService.payment(new WechatPaymentStrategy(), new BigDecimal("100"));
        //使用支付宝支付
        paymentService.payment(new AlipayPaymentStrategy(), new BigDecimal("100"));
    }
}
```

**总结**: 策略模式主要是在需要提供多种业务处理逻辑时, 提供任选的接口, 在拓展是只需要扩展新类即可, 而不需要修改原有的类, 满足开闭原则; 遇到工厂模式需要分类处理(if-else)的时候, 增加功能会违反 `开闭原则` , 策略模式则不会。 [Link1](https://www.cnblogs.com/ysocean/p/15635852.html) [Link2](https://mp.weixin.qq.com/s?__biz=MzIwNjg4MzY4NA==&mid=2247507414&idx=2&sn=ee20414b9c8bcfc2505c3a0110e2e583&chksm=971843dda06fcacba299e137e869496e0503bdba9841114f134736eb92fc4afe0a8cccae3e65&scene=21#wechat_redirect) [Link3](https://juejin.cn/post/7030976391596212255)



- JDK中使用策略模式的例子

  在JDK中最经典的使用策略模式的例子就是`Collections.sort(List<T> list, Comparator<? super T> c)`方法，这个方法接受一个比较器`Compartor`参数，客户端在运行时可以传入一个比较器的实现，`sort()`方法中根据不同实现，按照不同的方式进行排序。

- 策略模式使用场景

  在实际工作中，会有很多场景可以使用策略模式，比如上面例子中的多个支付方式，再比如与不同的第三方销售渠道对接等等。

  **总结一下**

  - 如果在一个系统里面有许多类，它们仅仅在行为上有区别，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为；
  - 一个系统需要动态地在几种算法中选择一种；
  - 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。



#### 4) 观察者模式

> 观察者模式又称为发布/订阅(Publish/Subscribe)模式,在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新(广播)。
>
> 在 `Java` 中，观察者模式通常由两个接口组成：`Subject` 和 `Observer`。`Subject`是被观察的对象，`Observer` 是观察者。`Subject` 接口定义了一系列方法，用于添加、删除和通知观察者，`Observer` 接口定义了一个 `update()` 方法，当 `Subject` 状态发生改变时，该方法被调用。

**实现**

在这个例子中，我们创建了一个`Subject`类，它包含一个列表`observers`，其中包含所有注册的观察者。`Subject`类还有一个状态`state`，它表示主题状态的变化。当状态改变时，`notifyAllObservers()`方法被调用，通知所有观察者更新它们的状态。

我们还创建了三个具体的观察者：`BinaryObserver`，`OctalObserver`和`HexaObserver`。每个观察者都需要一个`Subject`对象，并注册自己到该对象中。当`Subject`状态改变时，每个观察者都会收到通知并更新自己的状态，其中`update()`方法用于更新观察者状态。在`ObserverPatternDemo`类中，我们创建一个`Subject`对象，并向其注册三个观察者。然后，我们对主题进行两次状态更改，并在控制台输出每个观察者的状态。

@: `抽象类 Observer 与主题类 Subject, 实际观察者 A B C 分别继承抽象类。抽象类包含主题, 主题类包含观察者数组。在实际观察值设定主体的同时会把自身传递到主题类的观察者数组中, 这时就能够实现广播 - 调用更新。`

```java
import java.util.ArrayList;
import java.util.List;

public class Subject {
    private List<Observer> observers = new ArrayList<Observer>();
    private int state;

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
        notifyAllObservers();
    }

    public void attach(Observer observer){
        observers.add(observer);
    }

    public void notifyAllObservers(){
        for (Observer observer : observers) {
            observer.update();
        }
    }
}

public abstract class Observer {
    protected Subject subject;
    public abstract void update();
}

public class BinaryObserver extends Observer{

    public BinaryObserver(Subject subject){
        this.subject = subject;
        this.subject.attach(this);
    }

    public void update() {
        System.out.println( "Binary String: " + Integer.toBinaryString( subject.getState() ) );
    }
}

public class OctalObserver extends Observer{

    public OctalObserver(Subject subject){
        this.subject = subject;
        this.subject.attach(this);
    }

    public void update() {
        System.out.println( "Octal String: " + Integer.toOctalString( subject.getState() ) );
    }
}

public class HexaObserver extends Observer{

    public HexaObserver(Subject subject){
        this.subject = subject;
        this.subject.attach(this);
    }

    public void update() {
        System.out.println( "Hex String: " + Integer.toHexString( subject.getState() ).toUpperCase() );
    }
}

public class ObserverPatternDemo {
    public static void main(String[] args) {
        Subject subject = new Subject();

        new HexaObserver(subject);
        new OctalObserver(subject);
        new BinaryObserver(subject);

        System.out.println("First state change: 15");	
        subject.setState(15);
        System.out.println("Second state change: 10");	
        subject.setState(10);
    }
}
```

**OUT**

```cmd
First state change: 15
Hex String: F
Octal String: 17
Binary String: 1111
Second state change: 10
Hex String: A
Octal String: 12
Binary String: 1010
```

- **优点**
  1. 降低耦合性：观察者模式将主题（`Subject`）和观察者（`Observer`）之间的依赖关系解耦，使得它们可以独立地改变。主题不需要知道哪些观察者正在观察它，观察者也不需要知道主题的细节。
  2. 易于扩展：由于观察者模式是松散耦合的，因此可以很容易地添加或删除观察者，而不会影响主题或其他观察者。这使得代码更加灵活，易于扩展。
  3. 实现了开放/封闭原则：观察者模式遵循开放/封闭原则，即对于扩展是开放的，对于修改是封闭的。这意味着可以通过添加新的观察者来扩展系统的功能，而不必更改现有代码。
  4. 实现了可重用性：观察者模式将主题和观察者分离，使它们可以独立地进行测试和重用。
  5. 提高了灵活性和可维护性：观察者模式使得系统中的对象之间的通信变得更加灵活和可维护。它还使代码更易于理解和维护。
- **缺点**
  1. 内存泄漏：在观察者模式中，观察者需要注册到主题对象，当观察者不再需要时，需要从主题中注销，否则会导致内存泄漏。因为如果观察者对象没有被注销，则主题对象将保留对它的引用，这将防止观察者被垃圾回收。
  2. 性能问题：观察者模式在一些情况下可能会导致性能问题。当主题对象有大量观察者时，每当主题状态发生变化时，所有观察者都会被通知，这可能会导致性能问题。
  3. 并发问题：如果多个线程同时访问主题对象，并且主题对象在处理一个观察者时状态发生了变化，则可能会导致并发问题。因此，在使用观察者模式时需要小心处理并发问题。
  4. 对象的生命周期问题：观察者模式中的主题对象和观察者对象之间可能存在生命周期的问题。如果观察者对象在主题对象的生命周期内保持活动状态，这可能会导致一些不必要的问题



#### 5) 代理模式

- 静态代理

  `为其它所有对象编写代理类, 提供一种代理以控制对这个对象的访问(可以增强代码) - 外包 | 中介`

  假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。

  首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。

  ```php
  /** * 创建Person接口
   * @author Gonjan
   */public interface Person {    
       //上交班费    
       void giveMoney();
   }
  ```

  Student类实现Person接口。Student可以具体实施上交班费的动作。

  ```java
  public class Student implements Person {    
      private String name;    
      public Student(String name) {        
          this.name = name;    
      }
      @Override    
      public void giveMoney() {       
          System.out.println(name + "上交班费50元");    
      }
  }
  ```

  StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。

  ```java
  /** * 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为
   * @author Gonjan
   *
   */public class StudentsProxy implements Person{    
       //被代理的学生    
       Student stu;
      public StudentsProxy(Person stu) {        
          // 只代理学生对象        
          if(stu.getClass() == Student.class) {            
              this.stu = (Student)stu;        
          }    
      }
      //代理上交班费，调用被代理学生的上交班费行为    
       public void giveMoney() {        
           stu.giveMoney();    
       }
   }
  ```

  下面测试一下，看如何使用代理模式：

  ```cpp
  public class StaticProxyTest {    
      public static void main(String[] args) {        
          //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成        
          Person zhangsan = new Student("张三");
              //生成代理对象，并将张三传给代理对象        
          Person monitor = new StudentsProxy(zhangsan);
              //班长代理上交班费        
          monitor.giveMoney();    
  	}
  } 
  ```

- 动态代理

  不事先为每个需要代理的类写代理类, 而是在运行时动态的创建对应的代理类。实质上也就是通过反射技术, 在运行时判断是否需要代理, 如果需要代理的就使用反射获取对应的类再加以控制。



## 数据库

### 1 数据库引擎 innodb 和 myisam 的区别

- **innodb**: 支持事务、默认行级锁、删改性能更优、`innodb 聚簇与非聚簇索引都有 `

  支持MySQL事务，具有提交，回滚和崩溃恢复功能能够更加安全的保护用户数据；支持行级锁，提高多用户并发和性能；支持外键，维护数据完整性。

- **myisam**: 不支持事务、默认表级锁、查询性能更优、`MyisAM 引擎没有聚簇索引`。

  占用空间较小，支持表级锁，能够限制读写工作的负载的性能，查询效率较高，常用于只读场景。



### 2 聚簇与非聚簇索引(二级索引)

- **聚簇索引**

  找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。

- **非聚簇索引**

  索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询, 非聚簇索引也叫做辅助索引。

- **区别**

  索引与数据是否放在一起。 聚簇 - 在一起; 非聚簇 - 不在一起

  主键一定是聚簇索引, 其它普通索引需要区分SQL场景，当SQL查询的列就是索引本身时，我们称这种场景下该普通索引也可以叫做聚簇索引。



### 3 事务隔离级别 | 事务的 ACID 特性 | 实现原理

- 问题
  - 脏读: 一个事务读取了另一个事务未提交的数据
  - 不可重复读: 事务两次读取的数据不一致  - 数据不一致
  - 幻读: 事务两次读取数据库，两次查询结果的条数不同 - 数目不一致
  
- 事务隔离级别
  - 读未提交: 一个事务可以读到其他事物未提交的数据 
  - 读已提交: 一个事务可以读到其它事务提交的数据  避免 `脏读`
  - 可重复读: 一个事务两次读取到的数据相同  避免 `脏读` `不可重复读`
  - 串行化: 读取时加共享锁, 修改时加排它锁,效率最低。  避免 `脏读` `不可重复读` `幻读`
  
- ACID 特性
  - A(Atomicity - 原子性): 事务要么做要么不做
  - C(Consistency - 一致性): 事务执行的结果必须是使数据库从一个一致性状态变成另一个一致性状态。*张三向李四转100元，转账前和转账后的数据是正确的状态，这就叫一致性，如果出现张三转出100元，李四账号没有增加100元这就出现了数据错误，就没有达到一致性。*
  - I(Isolation - 隔离性): 事务的执行不能干扰其他事务
  - D(Durability - 持续性): 事务一旦完成，对数据库的修改是永久的
  
- 原理

  日志、锁、MVCC 等机制



### 4 MVCC 特性

*背*: `MVCC 是数据库中一种多版本并发控制逻辑。它会对每个事务设定一个版本号也即事务id, 通过隐藏字段存储。这时根据当前操作事务的id 与 ReadView 中的 m_ids(活跃事务ID)的最小值和最大值进行比较, 如果小于最小值则可见, 大于则不可见, 在此中间则根据当前事务ID是否位于m_ids中以及是否等于创建该ReadView的id判断, 如果不位于m_ids中或等于creator_id则可见, 其余不可见。然后根据ReadView的结果, 得到结果。`

> **Multi-Version Concurrency Control （多版本并发控制）**: 一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。MySQL 数据库管理系统使用的一种并发控制机制，它允许多个事务同时读取数据库中的数据，而不会出现读写冲突。
>
> 通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。数据库隔离级别**读已提交、可重复读** 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。   [Link](https://juejin.cn/post/7016165148020703246#heading-30)

- 关键点

  - 事务版本号: 事务开启前, 都会获取一个自增长的事务ID, 根据ID判断事务执行先后顺序。

  - 隐式字段: 对于InnoDB存储引擎，每一行记录都有两个隐藏列**trx_id**、**roll_pointer**，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列**row_id**。

    | 列名         | 是否必须 | 描述                                             |
    | ------------ | -------- | ------------------------------------------------ |
    | row_id       | 否       | 单调递增的行ID，不是必需的，占用6个字节。        |
    | trx_id       | 是       | 记录操作该数据事务的事务ID                       |
    | roll_pointer | 是       | 这个隐藏列就相当于一个指针，指向回滚段的undo日志 |

  - undo log: **回滚日志**，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。

    可以这样认为，当delete一条记录时，undo log 中会记录一条对应的insert记录，当update一条记录时，它记录一条对应相反的update记录。

    undo log 用途？

    1. 事务回滚时，保证原子性和一致性。
    2. 用于MVCC快照读。

  - 版本链: 多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为**版本链**。(实质上就是多个事务执行事务完成后得到的不同版本随机链接起来)

  - 快照读: 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读,如：

    ```sql
    select * from core_user where id > 2;
    ```

  - 当前读: 读取的是记录数据的最新版本，显式加锁的都是当前读

    ```csharp
    select * from core_user where id > 2 for update;
    select * from account where id>2 lock in share mode;
    ```

  - Read View

    事务执行SQL语句时，产生的读视图。实质上就是根据:

      m_ids:当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。

      min_limit_id:表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。

      max_limit_id:表示生成ReadView时，系统中应该分配给下一个事务的id值。

      creator_trx_id: 创建当前read view的事务ID

    *判断当前事务 trx_id 是否在 ReadView 之前|之后完成, 则可见|不可见。在两者中间根据情况讨论。*

    **Read view 匹配条件规则**:

    1. 如果数据事务ID `trx_id < min_limit_id`，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。
    2. 如果`trx_id>= max_limit_id`，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。
    3. 如果 `min_limit_id =<trx_id< max_limit_id`,需腰分3种情况讨论

    - 如果`m_ids`包含`trx_id`,则代表Read View生成时刻，这个事务还未提交，但是如果数据的`trx_id`等于`creator_trx_id`的话，表明数据是自己生成的，因此是**可见**的。
    - 如果`m_ids`包含`trx_id`，并且`trx_id`不等于`creator_trx_id`，则 ReadView生成时，事务未提交，并且不是自己生产的，所以当前事务也是**看不见**的；
    - 如果`m_ids`不包含`trx_id`，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。

- 原理分析

  - 查询一条记录，基于MVCC，是怎样的流程

    1. 获取事务自己的版本号，即事务ID
    2. 获取Read View
    3. 查询得到的数据，然后Read View中的事务版本号进行比较。
    4. 如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;
    5. 最后返回符合规则的数据

    InnoDB 实现MVCC，是通过` Read View+ Undo Log` 实现的，Undo Log 保存了历史快照，Read View可见性规则帮助判断当前版本的数据是否可见。

  - 当一个事务对数据库进行修改时，MySQL不会直接修改原始数据，而是将其标记为删除，并创建一个新版本的数据。新版本的数据会被加上新的创建时间和事务ID。

  - 当一个事务查询数据时，MySQL会根据该事务ID和创建时间来确定该事务能够看到哪些数据版本。如果该事务的开始时间早于某个数据版本的创建时间，则该事务不能看到该数据版本。

  - 当一个事务提交时，MySQL会将该事务的所有修改操作应用到数据库中，并将其事务ID与当前时间一起记录在数据库的undo日志中，用于回滚操作。

**MVCC 机制的好处是可以允许并发的读取和写入，提高数据库的并发性能。同时，MVCC也提供了高度的隔离性，保证了事务之间的数据不会相互影响。**



### 5 MySQL 加锁方式

在MySQL中，可以通过使用锁来控制并发访问数据库的行为。MySQL支持多种类型的锁，包括行级锁和表级锁。以下是MySQL中常用的加锁方式：

- 行级锁

  行级锁可以在MySQL中使用SELECT ... FOR UPDATE语句进行加锁。该语句会在查询时对选中的行进行加锁，防止其他事务同时对同一行进行修改。例如：

  ```
  SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
  ```

  该语句会将id为1的行加上行级锁，直到当前事务提交或回滚之前，其他事务无法对该行进行修改。

- 表级锁

  表级锁可以在MySQL中使用LOCK TABLES语句进行加锁。该语句会将整个表加上锁，防止其他事务对该表进行修改。例如：

  ```
  LOCK TABLES table_name WRITE;
  ```

  该语句将table_name表加上写锁，其他事务无法对该表进行写操作，直到当前事务提交或回滚之后，锁才会释放。



### 6 慢 SQL 优化

*定位慢 SQL* -> `Explain 分析执行计划` -> *profile 耗时分析* -> `optimizer trace 分析详情`

- **慢 SQL 定位**

  `通过慢查询日志定位慢 SQL,` 

- **EXPLAIN**

  `通过执行计划分析索引和IO开销, 定位原因。`

  ```sql
  explain select * from user where id > 1;
  ```

  | 列名          | 含义                                                         |
  | ------------- | ------------------------------------------------------------ |
  | select_type   | select 子句类型                                              |
  | partitions    | 匹配的分区                                                   |
  | type          | 访问类型，即怎么找数据行的方式(ALL, index, range, ref, eq_ref, const, system, NULL  从左到右效率越来越高) |
  | possible_keys | 能使用的索引                                                 |
  | key           | 预测使用的索引                                               |
  | key_len       | 索引使用的字节数                                             |
  | ref           | 连接匹配条件                                                 |
  | rows          | 估算出所查到的数据行数                                       |
  | filtered      | 通过条件过滤出的行数所占百分比估计值，1~100，100表示没有做任何过滤 |
  | Extra         | 该列包含MySQL解决查询的详细信息                              |

  慢 SQL 的常见原因：

  - 索引使用问题，通过两个字段分析

    ```
    possible_keys(能用到的索引) | key(实际用到的索引)
    ```

    - 没有使用索引
    - 优化器选择了错误索引
    - 没有实现覆盖索引

  - I/O开销问题，通过两个字段分析

    ```
    filtered(有效行数/扫描行数比值) | rows(执行当前查询要遍历的行数)
    ```

    - 扫描的行数过多
    - 返回无用列且无用列有明显I/O性能开销(比如text、blob、json 等类型）

- **PROFILE**

  `show profile 分析实际SQL执行过程中的资源消耗情况, 进一步分析慢SQL。`

  后续执行的SQL语句都会记录其资源开销，包括 IO，上下文切换，CPU，Memory、执行耗时 信息。

- **Optimizer Trace**

  `分析优化器如何选择执行计划, 如何实际执行SQL语句。`

- **优化方案**

  **不使用子查询**

  ```text
  SELECT * FROM t1 WHERE id (SELECT id FROM t2 WHERE name='hechunyang');
  ```

  在MySQL5.5版本中，内部执行计划器是先查外表再匹配内表，如果外表数据量很大，查询速度会非常慢

  再MySQL5.6中，有对内查询做了优化，优化后SQL如下

  ```text
  SELECT t1.* FROM t1 JOIN t2 ON t1.id = t2.id;
  ```

  但也仅针对select语句有效，update、delete子查询无效，所以生产环境不建议使用子查询

  **避免函数索引**

  ```text
  SELECT * FROM t WHERE YEAR(d) >= 2016;
  ```

  即使d字段有索引，也会全盘扫描，应该优化为：

  ```text
  SELECT * FROM t WHERE d >= '2016-01-01';
  ```

  **使用IN替换OR**

  ```text
  SELECT * FROM t WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30;
  ```

  非聚簇索引走了3次，使用IN之后只走一次：

  ```text
  SELECT * FROM t WHERE LOC_IN IN (10,20,30);
  ```

  **LIKE双百分号无法使用到索引**

  ```text
  SELECT * FROM t WHERE name LIKE '%de%';
  ```

  应优化为右模糊

  ```text
  SELECT * FROM t WHERE name LIKE 'de%';
  ```

  **增加LIMIT M,N 限制读取的条数避免数据类型不一致**

  ```text
  SELECT * FROM t WHERE id = '19';
  ```

  应优化为

  ```text
  SELECT * FROM t WHERE id = 19;
  ```

  **分组统计时可以禁止排序**

  ```text
  SELECT goods_id,count(*) FROM t GROUP BY goods_id;
  ```

  默认情况下MySQL会对所有GROUP BY co1，col2 …的字段进行排序，我们可以对其使用

  ```text
  ORDER BY NULL
  ```

  **禁止排序，避免排序消耗资源**

  ```text
  SELECT goods_id,count(*) FROM t GROUP BY goods_id ORDER BY NULL;
  ```

  **去除不必要的ORDER BY语句**

  **总结**

  总的来说，我们知道慢查询的SQL后，优化方案可以做如下尝试：

  1. SQL语句优化，尽量精简，去除非必要语句
  2. 索引优化，让所有SQL都能够走索引
  3. 如果是表的瓶颈问题，则分表，单表数据量维持在2000W（理论上）以内
  4. 如果是单库瓶颈问题，则分库，读写分离
  5. 如果是物理机器性能问题，则分多个数据库节点



### 7 MySQL 的索引 | 索引失效 | 联合索引 | 索引分类

MySQL 使用 Innodb 引擎, 底层由 B+ 树实现, 索引可以加快数据查询的速度。常见的索引失效场景包括: 

- **索引失效**

  - **原因**

    不使用索引列查询

    使用索引列进行范围查询(索引未完全覆盖范围内数据)

    更新频繁的表

    索引列上存在函数或表达式。

    违反最左前缀法则

    - 字符串不加单引号，造成索引失效。(类型转换)
    - 以 % 开头的 Like 模糊查询，索引失效

  - **解决方法**

    首先确认索引是否正确使用, 通过查询语句查看执行计划查看索引类型。然后查看查询语句是否会引起索引失效的情况, 其次再查看数据结构是否影响索引建立。

- **联合索引**

  指在多个列上创建的索引, 可以同时覆盖多个列, 提供更好的查询效果。 

  `① 是否使用联合索引的前缀列: 如索引 A、B、C, 使用 A | AB | ABC 均可使用联合索引, BC 则不可以, 因为不符合最左前缀 - 同时ABC的顺序可以乱序只要包含即可`

  `② 排序与分组是否与联合索引列顺序不一致` 

  `③ 表更新的频率: 太高会导致失效`

- **索引分类**

  主键索引(PRIMARY KEY): 某一个属性组可以标识一条记录。

  唯一索引(UNIQUE): 避免同一个表中某些数据列重复。

  常规索引(INDEX): 快速定位数据

  联合索引(UNION INDEX): 多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。遵循最左前缀集合

  全文索引(FULLTEXT): 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。

- **索引级别**

  `system > const > eq_ref > ref > range > index > ALL`



### 8 SQL 的执行结果

- 在打开客户端后，最初需要和 SQL服务器建立连接，账号认证和校验权限。

- 认证后，客户端发生查询 SQL脚本 给服务器

- 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。

- 服务器端进行 SQL解析、预处理，再由优化器生成对应的执行计划。

- MySQL 根据优化器生成的执行计划，再调用存储引擎的API来执行查询。

- 将结果返回给客户端。

<img src="https://img-blog.csdnimg.cn/f5e93d9217484c438a7d7295b2e15d7d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riF6aOO5ZKM5pyI5piO,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述" style="zoom:50%;" />



### 9 undo | redo | binlog

- `Undolog（回滚日志）`

  Undolog 用于处理事务的回滚操作。当一个事务执行更新或删除操作时，相关数据会被存储在回滚日志中，以便在事务回滚或并发控制需要时进行数据恢复。Undo日志记录了对数据的旧值进行修改的操作，以便在需要时可以撤消事务的更改。

- `Redolog（重做日志）`

  Redolog 用于确保事务的持久性（durability）。当事务提交时，相关的数据修改操作将被记录在重做日志中。重做日志的目的是在数据库崩溃或意外关闭后，通过重新执行日志中的操作，将数据恢复到崩溃之前的状态。

- `Binlog（二进制日志）`

  Binlog 是 MySQL 中的二进制日志文件，用于记录数据库的所有更改操作。它包含了对数据库执行的所有更新、插入、删除等操作的日志记录。Binlog 对于数据恢复、主从复制以及数据库的增量备份和恢复非常重要。通过读取 Binlog 文件，可以将这些操作应用到其他数据库实例上，实现数据的复制和同步。











## RabbitMQ

### 1 RabbitMQ 延时消息如何实现

通过消息的`延时级别（Delay Level）`来实现的。延时级别是一个预定义的参数，用于指定消息发送后的延时时间。延时级别是通过设置消息的属性来实现的。

- 延时级别

  RabbitMQ 配送的延时时间间隔有 1s，5s，10s，30s，1m，2m，3m，4m，5m，6m，7m，8m，9m，10m，20m，30m，1h，2h 对应 1,2,3,4...n, 用等级来表示时间间隔。

- Broker持久化延时消息

  Broker对于接收到的消息首先会判断一下是不是延时消息，如果是延时消息会将消息以 SCHEDULE_TOPIC_XXXX 为 topic 替换原有的 topic名称进行持久化，实现方法在CommitLog的putMessage中。

- 延时消息处理

  通过 `定时任务服务 ScheduleMessageService` 的方式不断的读取topic为SCHEDULE_TOPIC_XXXX何queueId为延时等级的消息进行消息还原处理，这样消息被还原之后消费者就可以拉取消息了。

- 消费者消费消息













## Java SE

### 1 接口与抽象类的区别

- 接口

  使用 `Interface` 关键字修饰

  支持多继承, 一个接口可以继承多个接口, 一个类可以实现多个接口

  接口只能有定义, 不能有方法的实现

  接口可以包含变量、方法

  接口变量默认为 `public static final`, 必须赋初值, 不能被修改

  **需要实现统一的行为接口**

- 抽象类

  使用 `abstract` 关键字修饰

  不能被实例化只能被继承

  包含抽象方法的一定是抽象类, 抽象类不一定有抽象方法

  可以有方法的定义和实现

  抽象类可以包含属性、方法、构造方法

  抽象类变量默认`default`, 可在子类中重新定义, 也可被重新赋值

  **在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。**

- 相同点

  不能被实例化; 继承抽象类和实现接口的子类都要实现声明的抽象方法



### 2 Java 基本类型和引用类型 | 装箱拆箱

8种基本类型: 

`byte 8` `short 16` `int 32` `long 64` `float 32` `double 64` `char 16` `boolean` (不同JVM大小不同)

其他数据类型如: 数组、类、接口、String 等在生命时不会被立即分配内存, 只是存储了内存地址。



`自动装箱`: 将基本类型赋值给对应的包装类型。 

`自动拆箱`: 将包装类型对象赋值给基本类型。

通过自动装箱、自动拆箱功能,简化基本类型变量和包装类对象之间的转换过程。

| 基本数据类型 | 对应包装类 |
| ------------ | ---------- |
| byte         | Byte       |
| short        | Short      |
| int          | Integer    |
| long         | Long       |
| float        | Float      |
| double       | Double     |
| char         | Character  |
| boolean      | Boolean    |



### 3 final | static

- **final**

  final 修饰类, 该类不可被继承;

  final 修饰方法, 该方法不能被重写;

  final 修饰变量, 基本类型值不可改变, 引用类型值可变地址不可变;

- **static**

  Java类中包含: 成员变量、方法、构造器、初始化块和内部类（包括接口、枚举）5种成员。

  `static` 关键字可以修饰除了构造器外的其他4种成员。

  静态方法只能访问用 `static` 修饰的成员 

  1. 修饰方法与成员变量  

     *静态变量是在类初始化之前就在方法去的静态域中分配内存空间了* *程序运行结束时被销毁*

     static 修饰的变量是存储于方法区的, 表示类方法或者类成员变量，是所有对象所共享的。可以通过类名调用，也可以通过实例对象调用。  *无需创建对象就可以个使用这个属性*

  2. 静态代码块:

     当类被加载时，静态代码块会执行一次，因为一个类只加载一次，所以静态代码块只执行一次。通常使用静态代码块对类的成员变量进行初始化。  *优先于普通代码块先执行* *静态代码块可以给静态成员变量和静态常量进行赋值* *调用当前类的静态方法时会先执行静态代码块* *静态代码块-->普通代码块-->构造器*

  3. 修饰内部类 

     可以在不创建外部类对象的情况下被实例化。

     *静态内部类可以定义静态变量、静态常量、静态方法，普通内部类则不可以。普通内部类只可创建普通的成员变量和方法，和static有关的操作都不可使用。*

     *在其他对象中可以创建静态内部类的实例对象，例如TestStatic.ClassStatic tcs = new TestStatic.ClassStatic();*

     *静态内部类与外部类是平级, 访问需要 new*

     *静态内部类属于类, 普通内部类属于对象*



### 4 String | String、StringBuffer、Stringbuilder

- **String**

  String 类由 `final` 修饰, 所以它不可被继承。 

  *创建方式不同*

  - 直接赋值

    直接赋值方式创建 `String` 对象, 现在常量池检查是否有相同内容字符串,  有直接返回, 没有才执行创建。    `存储在字符串常量池`

  - new

    至少会创建一个对象，也有可能创建两个。使用new创建字符串时, 首先在堆中创建字符串, 再判断常量池是否有该字符串,如果有指向堆内变量; 没有则创建并指向堆内变量。  `存储在堆`

  - 区别

    直接赋值更高效, 可以节约内存和提高性能。而使用 `new` 关键字创建的字符串对象在堆内存中独立存储，适用于需要动态创建和修改字符串的情况。

- *String | StringBuffer | Stringbuilder 区别*

  Java 提供了 String、StringBuffer 两个类和大量的方法来封装字符串。

  String 被创建后不可变、效率低, 但复用率高; 

  StringBuffer 创建后可变、效率高, 线程安全; 

  StringBuilder 也可变、效率最高, 但线程不安全; 

  `总结`: 单线程下使用 StringBuilder 效率高; 多线程下使用 StringBuffer, 保证安全性。



### 5  == 与 equals() 的区别 | 为什么重写 equals() 就要重写 hashCode()

- **区别**

  `==` 比较基本类型时比较值是否相等, 引用类型则比较地址是否相等; 

  `equals()` 没有重写之前与 `==` 一致, 重写后可使用 按值比较。

- **equals() 与 hashCode()**

  `hashCode` 用于获取哈希值, `equals()` 用于比较对象是否相等; 如果两个对象相等, 它们必须有相同的哈希码；若两个对象的哈希码相同, 他们却不一定相等。也就是说, equals() 比较两个对象相等时 hashCode() 一定相等, hashCode() 相等的两个对象 equqls() 不一定相等; 由于hashCode() 与 equals() 具有联动关系, equals() 重写时, hashCode() 进行重写, 使得这两个方法始终满足相关的约定。







### 7 Java 集合

List、Set 实现 Collection接口， Map 顶级接口

- **List** 

  ArrayList  数组实现的，常用于查询。
  LinedList  链表实现的，常用与增删改查。

- **Set** 

  HashSet  哈希表实现的，数据无序。

  TreeSet  二叉树实现的，数据自动排序。

- **Map** 

  HashMap  线程不安全，效率快，适用于单线程操作

  TreeMap   二叉树实现的，数据有序，HashTable 与 HashMap无序

  HashTable  线程安全，因为底层都加了 synchronized 关键字来确保线程同步，适用于多线程操作



## JUC

> 基本概念:
>
> - 原子性
>   定义: 即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
> - 可见性
>   定义: 指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
> - 有序性
>   定义: 即程序执行的顺序按照代码的先后顺序执行。



### 1 Sychronized | ReentrantLock | ThreadLocal

> Java 常用的锁和原理: `Synchronized` 和 `Lock` 

#### 1) Sychronized

`Sychronized ` 保证原子性(要么都做要么都不做)、资源可见性(变量的修改可以被其他线程看到)、有序性(指令按固定顺序执行 - volatile)。 

特点: `用于修饰静态方法(等于给类加锁)、代码块、普通方法`; `关键字`; `synchronized 可以自动释放`; `synchronized 不可以判断加锁状态`; `非公平锁`; `粒度较粗`



#### 2) Lock

*Lock* 是一个接口, 其中继承其的类有: 读锁、写锁、可重入锁(ReentrantLock)等, 其中最常见的是 ReentrantLock。常用方法包括 `lock() 获取锁` : `unlock() 释放锁` : `tryLock() 尝试获取锁` 等。特点: `接口`; `Lock 加锁不会自动释放`; `Lock 可以通过 tryLock() 判断加锁状态`; `公平锁 | 非公平锁`; `粒度较细`

<img src="imgs/1771072-20200216201818148-1683117055-16937248890052.png" alt="img" style="zoom: 67%;" />





#### 3) ReentrantLock

`ReentrantLock` 继承了 `Lock` 接口来处理对共享对象的访问, 保证变量的互斥性和内存可见性。它的特点与 `Lock` 一致。如: `Lock 加锁不会自动释放`; `Lock 可以通过 tryLock() 判断加锁状态`; `公平锁 | 非公平锁`; `粒度较细`





#### 4) ThreadLocal

> 线程局部变量: 全称 thread local variable, 它的使用场合主要是为了解决多线程中因为数据并发产生不一致的问题。 ThreadLocal为每一个线程都提供了变量的副本，使得每一个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享，这样的结果无非是耗费了内存，也大大减少了线程同步所带来的性能消耗，也减少了线程并发控制的复杂度。
>
> `* ThreadLocal 是 Java 中的一个线程级别的变量存储工具类，它提供了一种在多线程环境下，每个线程都拥有自己独立的变量副本的机制。 *`	
>
> **主要是为了解决多线程中因为数据并发产生不一致的问题; 同时可以保证同一个线程内, 不同方法之间的属性共享问题;每个线程都有一个 ThreadLocalMap 变量, ThreadLocalMap的存储位置是在Thread线程中。 **  [Link](https://juejin.cn/post/7042211997743579144)



ThreadLocal 是 JDK包提供的，它提供线程本地变量，如果创建一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题，如下图所示。

<img src="imgs/1368768-20190613220434628-1803630402.png" alt="img" style="zoom:50%;" />

- **实现原理**

  哈希表 - ThreadLocalMap 实现。 `get ` `set` `remove`

- **优点**

  1. 线程封闭性（Thread Confinement）：ThreadLocal 可以实现将变量绑定到当前线程，使得变量对其他线程不可见，实现了线程封闭性。这在多线程环境下，可以避免共享变量引起的线程安全问题。
  2. 线程上下文传递（Thread Context Propagation）：ThreadLocal 可以用于在线程之间传递上下文信息。比如，在 Web 应用中，可以将当前用户的登录信息存储在 ThreadLocal 中，这样在不同的业务方法中都可以方便地获取到用户的登录信息。
  3. 隐式参数传递（Implicit Parameter Passing）：ThreadLocal 可以用于将一些公共参数在方法调用链中隐式传递，避免在每个方法参数中显式传递这些参数。这样可以简化方法的调用，提高代码的可读性。
  4. 数据隔离（Data Isolation）：在一些需要数据隔离的场景下，ThreadLocal 可以用于实现数据的隔离。比如，在数据库连接池中，可以使用 ThreadLocal 来保存每个线程使用的数据库连接，确保每个线程使用自己的连接，避免数据混乱。

- **源码**

  ThreadLocal源码中常用的方法有get、set和remove，这几个函数的源码很简单

  ```java
  public T get() {
      Thread t = Thread.currentThread();
      ThreadLocalMap map = getMap(t);
      if (map != null) {
          ThreadLocalMap.Entry e = map.getEntry(this);
          if (e != null) {
              @SuppressWarnings("unchecked")
              T result = (T)e.value;
              return result;
          }
      }
      return setInitialValue();
  }
  
  public void set(T value) {
      Thread t = Thread.currentThread();
      ThreadLocalMap map = getMap(t);
      if (map != null)
          map.set(this, value);
      else
          createMap(t, value);
  }
  public void remove() {
      ThreadLocalMap m = getMap(Thread.currentThread());
      if (m != null)
          m.remove(this);
  }
  ```

  这几个函数中都要先调用getMap这个函数来获取ThreadLocalMap对象，然后操作这个map对象来实现变量的存取。看下getMap这个函数

  ```java
  ThreadLocalMap getMap(Thread t) {
      return t.threadLocals;
  }
  ```

- 案例

  ```java
  package test;
  
  public class ThreadLocalTest {
  static ThreadLocal<String> localVar = new ThreadLocal<>();
  
  static void print(String str) {
      //打印当前线程中本地内存中本地变量的值
      System.out.println(str + " :" + localVar.get());
      //清除本地内存中的本地变量
      localVar.remove();
  }
  
  public static void main(String[] args) {
      Thread t1  = new Thread(new Runnable() {
          @Override
          public void run() {
              //设置线程1中本地变量的值
              localVar.set("localVar1");
              //调用打印方法
              print("thread1");
              //打印本地变量
              System.out.println("after remove : " + localVar.get());
          }
      });
  
      Thread t2  = new Thread(new Runnable() {
          @Override
          public void run() {
              //设置线程1中本地变量的值
              localVar.set("localVar2");
              //调用打印方法
              print("thread2");
              //打印本地变量
              System.out.println("after remove : " + localVar.get());
          }
      });
  
      t1.start();
      t2.start();
  }
  }
  
  >threadl : localVar1
  >after remove : null
  >thread2 : localVar2
  >after remove : null
  ```

- **内存泄露**

  ThreadLocal的引用在线程运行中，在没有执行remove的情况下被设置为null，即释放了强引用，ThreadLocal对象只有Entry的弱引用了。下次gc被回收，key是弱引用被回收，value是强引用一直存储在内存中。线程还在运行，value的内存就不会释放，这样发生了内存泄漏。

  

#### 5) 区别

1. `Synchronized` 和 `Lock` 

- **Synchronized**

  `关键字`; `synchronized 可以自动释放`; `synchronized 不可以判断加锁状态`; `非公平锁`; `粒度较粗`

  synchronize 的用法及原理:

  synchronized 可以。它能够保证同一时间只有一个线程执行该代码, 保证线程安全。它能够在执行完毕或出现异常后自动释放锁。底层是采用Java对象头来存储锁信息的,并且还支持锁升级。在JVM里的实现都是 基于进入和退出 Monitor 对象来实现方法同步和代码块同步。synchronized 加在普通方法上, 锁当前实例; 加在静态方法, 锁当前类的从class对象;加在代码块上, 则需要在关键字后面的小括号里, 显式指定一个对象作为锁对象。

- **Lock**

  `接口`; `Lock 加锁不会自动释放`; `Lock 可以通过 tryLock() 判断加锁状态`; `公平锁 | 非公平锁`; `粒度较细`

2. `Synchronized` 与 `ThreadLocal`  

   ThreadLocal 和 Synchonized 都用于解决多线程的并发访问; Synchronized是利用锁的机制，使得变量或者是代码块在某一时刻里只能被一个线程来进行访问。ThreadLocal是为每一个线程都提供了一个变量的副本，这样每一个线程在某一时刻里访问到的不是同一个对象，这样就隔离了多个线程对数据的数据共享。



### 2 公平锁和非公平锁 | 可重入锁

- 公平锁

  所有线程按申请顺序获得锁, 队列第一个才可以获得锁。

  - 优点：所有的线程都能得到资源，不会饿死在队列中。
  - 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

- 非公平锁

  所有线程获取锁先尝试, 没有的话才等待, 否则直接拿到锁。

  - 优点：可以减少 CPU 唤醒线程的开销，整体的吞吐效率会高点，CPU 也不必取唤醒所有线程，会减少唤起线程的数量。
  - 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

- 可重入锁

  实质上就是一个线程可以多次获得某个锁而不会出现死锁。 `Sychronized` 与 `ReentrantLock` 都是可重入的锁

- Lock实现公平锁与非公平锁方法

  ReentrantLock 的构造函数可以传入一个boolean参数，用于控制锁的公平性, 如下所示

  ```java
  public ReentrantLock() {
      sync = new NonfairSync();
  }
  public ReentrantLock(boolean fair) {
      sync = fair ? new FairSync() : new NonfairSync();
  }
  ```

  公平锁会有 `hasQueuedPredecessors` 方法判断该线程是否位于队列头部, 只有在队列头部的线程才能获得锁。



### 3 volatile 的用法及原理

`volatile 是一个Java的关键字，用来解决内存可见性问题的。它能够保证线程之间可见, 通过添加屏障的方式避免指令重排序导致的线程安全问题。`  **只保证可见性和有序性, 不保证互斥性。**

*应用场景*: 被 volatile 修饰的变量保证对所有线程可见, 可以用于状态标志位, 检查某个线程运行状态、任务完成状态等; 线程之间的共享变量; 

- 保证线程之间的可见性

  volatile 关闭 JIT(即时编译器) 对其所修饰变量的优化(多线程并发的情况下, JIT 优化有时候会导致非预期的结果)

- 禁止指令重排序

  volatile 禁止指令重排序(添加内存屏障)

  写操作加的屏障是阻止上方其它写操作越过屏障排到 volatile 变量写之下
  读操作加的屏障是阻止下方其它读操作越过屏障排到 volatile 变量读之上

  volatile使用技巧:

  - 写变量让 volatile 修饰的变量的在代码最后位置
  - 读变量让 volatile 修饰的变量的在代码最开始位置



### 3 Sychronized 锁升级

`无锁 ----> 偏向锁 ----> 轻量级锁 ----> 重量级锁`   锁升级是不可逆的，只能升级不能降级

- `无锁`

  不添加锁

- `偏向锁`

  **为什么引入**: 解决只有一个线程执行同步代码时提高性能。

  **升级过程**: 就是在锁对象的对象头中有个 `ThreadId` 字段, 这个字段如果是空的，线程第一次获取锁的时候，就将线程自身的 `ThreadId` 写入到锁的 `ThreadId` 字段内，将锁头内的是否偏向锁的状态位置 1。这样下次获取锁的时候，直接检查ThreadId是否和自身线程Id一致，如果一致，则认为当前线程已经获取了锁，因此不需再次获取锁，略过了轻量级锁和重量级锁的加锁阶段。

  **撤销过程**: 只有当其他线程竞争该锁时，持有偏向锁的线程才会被撤销，释放该偏向锁。并且撤销需要等待全局安全点，也就是该时间点没有字节码正在执行。

  **作用**: 当一段同步代码一直被同一个线程多次访问时，由于只有一个线程，该线程后续访问时无需再次获取锁。  -  性能高

- `轻量级锁`

  轻量级锁，偏向锁是单线程下的锁优化，这个就说多线程下的锁优化了，当有多个 线程竞争同一个临界资源，这个时候偏向锁就会被撤（这个步骤也是十分消耗资源的），然后升级为轻量级锁，这个也是一个基于 CAS 的乐观锁。

  **为什么引入 | 作用**: `在线程近乎交替执行同步代码时提高性能`。轻量级锁是为了在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统的 Mutex Lock 带来的性能消耗，轻量级锁适用于线程交替执行同步代码的场景。所以轻量级锁是为了在线程近乎交替执行同步代码时提高性能。

  **升级过程**: *线程 A 与 线程 B 同时抢占锁对象时，偏向锁会被撤销并将锁升级为轻量级锁。*线程 A 在执行同步代码前，JVM 在线程的栈帧中创建用于存储锁记录的空间 Lock Record。当线程 A 抢占锁对象时，JVM 使用 CAS 操作将锁对象的对象头的 Mark Word 拷贝进线程 A 的锁记录 Lock Record 中（这个拷贝 Mark Word 的过程官方称为 `Displaced Mark Word`），并且将 Mark Word 中指向线程栈中 Lock Record 的指针指向线程 A 的锁空间。如果更新成功，则线程 A 持有该对象锁，并将对象锁的 Mark Word 的锁标志位更新为 00。即此时线程 A 持有轻量级锁会执行同步代码，而线程 B 会自旋等待获取该轻量级锁；如果更新失败，则说明该锁被线程 B 抢占。

  **撤销过程**: 1. 当有两个以上的线程同时竞争一个锁时，那么轻量级锁会被撤销并升级为重量级锁，不再通过自旋的方式等待获取锁而是直接阻塞线程；

  ​		  2. 当持有轻量级锁的线程执行完同步代码时，同样会释放轻量级锁，会使用 CAS 操作将锁对象的 Mark Word 中指针指向的锁记录 Lock Record 重新替换回锁对象的 Mark Word。

- `重量级锁`

  当存在两个以上的线程竞争同一把锁或线程竞争轻量级锁自旋多次仍然失败时，会导致锁升级为重量级锁。重量级锁会直接阻塞持有锁的线程以外的所有线程，防止 CPU 空转，减小 CPU 的开销。通过将锁对象的 Mark Word 的锁标志位更新为 10，从而将锁升级为重量级锁。此时可以看到 Mark Word 中有一个指向互斥量的指针，这个指针其实指向的就是 Monitor 对象的起始地址，通过 Monitor 对象即可实现互斥访问同步代码，也就是通过阻塞唤醒的方式实现同步。

- `锁自旋`

  锁自旋，什么是锁自旋呢，很简单就是线程自己做一些无用功，避免线程被挂起阻塞 ，它自己在哪里做一些空任务，然后去竞争锁，避免被挂起阻塞（阻塞和唤醒是又是十分消耗性能的行为，这边涉及到用户态和核心态的操作系统问题，一般我们操作的都是用户态，但是线程的挂起阻塞是需要从用户态切换到核心态，同样，线程唤醒也一样，这个步骤会造成巨大的性能消耗，能避免尽量避免）。当然，锁自旋也是会消耗一定的 CPU 的。

- 总结

  以上就是 synchronized 的锁升级内容了，JDK 1.6 之后采用锁升级的方式来优化 synchronized 同步锁，提高了程序的运行效率。接下来总结一下偏向锁、轻量级锁、重量级锁三者的优缺点以及使用场景。

  |  锁类型  |                             优点                             |                             缺点                             |
  | :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
  |  偏向锁  | `只有一个线程`访问同步代码时，只在置换ThreadID时进行一次CAS操作，锁的开销低，性能接近于无锁状态。 | 线程间存在竞争时，需要频繁暂停持有锁的线程并检查状态和撤销锁，反而带来额外的开销。 |
  | 轻量级锁 | (`两个线程`)线程间存在交替竞争时，竞争的线程不需要阻塞，提高了响应速度。 | 当大量线程存在竞争时，线程始终的抢占不到锁，会导致CPU空转消耗CPU性能。 |
  | 重量级锁 | `(多个线程竞争一个)`通过阻塞唤醒的方式实现同步，防止CPU空转，不会消耗CPU性能。 | 线程阻塞导致响应时间变长，频繁切换CPU状态，导致性能消耗增大。 |

  根据三类锁的优缺点可以知道使用场景：

  - 偏向锁：**适用于单线程的情况**，在不存在锁竞争的时候进入同步代码可以使用偏向锁。
  - 轻量级锁：**适用于竞争较不激烈且同步代码执行时间较短的情况**，存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁要更高效。
  - 重量级锁：**适用于竞争激烈且同步代码执行时间较长的情况**，此时使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。



### 5 JUC | CAS | AQS

`JUC(java.util.concurrent)` 包含多个支持并发操作的工具, 是Java支持并发操作的核心, 包括线程操作、线程池、并发容器、原子操作的具体实现。

- 原子类: 遵循 CAS(比较和替换)原则, 可用于解决单个变量的线程安全问题。
- 锁: 在包含 Synchronized 所有功能基础上, 支持超时和响应中断机制, 主要解决多个变量的线程安全问题。
- 线程池: 可以方便的管理线程, 避免重复开关线程导致的消耗。
- 并发容器: 例如ConcurrentHashMap，支持多线程操作的并发集合，效率更快。 

`CAS(Compare And Swap - 比较和替换)`

- CAS的全称是 Compare-and-Swap，也就是比较并交换，是并发编程中一种常用的算法。

  它包含了三个参数：V，A，B。其中，V表示要读写的内存位置，A表示旧的预期值，B表示新值。

  `CAS` 的核心思想是：在执行操作之前，先比较当前内存中的值是否等于期望值，如果相等，则执行修改操作；如果不相等，则不执行修改操作，继续进行比较，直到内存中的值与期望值相等为止。这个过程中不会出现线程的阻塞和唤醒，因此可以提高系统的并发性能。 CAS 操作需要输人两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。

`AQS (Abstract Queued Synchronizer - 队列同步器)`

- **概念**: 用来构建锁和同步器的框架, 用于实现锁和其他同步组件和维护共享资源, 使用队列让线程进行排队的过程, Lock 基于其实现。

- **理解**: `AQS` 通过一个 `FIFO` 队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制。

- **原理**: AQS 维护了一个 `valatile int state` 变量和 `CLH 虚拟双向队列`(即不存在队列实例，仅存在节点之间的关联关系), 队列中的节点持有线程引用，每个节点均可通过`getState()`、`setState()`和`compareAndSetState()`对`state`进行修改和访问。当线程获取锁时，即试图对`state`变量做修改，如修改成功则获取锁；如修改失败则包装为节点挂载到队列中，等待持有锁的线程释放锁并唤醒队列中的节点。

  <img src="imgs/e22dfb7003ee44afb6f80ddfbce68a93tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="img" style="zoom:50%;" />



### 6 分布式锁

> 当多个进程不在同一个系统中，用于控制多个进程对资源访问的锁





### 7 线程池 创建 | 核心参数 | 扩容与缩容策略

- **创建**

  一般使用 Executors 类创建, 提供了 4 个通用方法:

  - `newCachedThreadPool()` 

    线程数量随着任务增加⽽增加，如果线程执⾏完毕却空闲了⼀段时间则会被回收
    特点：没有核⼼线程数，也不会有缓冲队列，⼀个任务对应会创建⼀个线程，线程的最⼤空闲时间 1分钟。

    ```java
    public class TreadPoolTest {
        public static void main(String[] args) {
            ExecutorService executorService1 = Executors.newCachedThreadPool();
            ExecutorService executorService2 = Executors.newFixedThreadPool(10);
            ExecutorService executorService3 = Executors.newSingleThreadExecutor();
            for (int i = 0; i < 100; i++) {
            int idx = i;
            executorService1.submit(() ->
            	System.out.println(Thread.currentThread().getName() + " task execution i = " + idx));
            }
        }
    }
    ```

  - `newFixedThreadPool`

    创建固定线程数量的线程池，如果某个线程因为执⾏异常⽽结束，那么线程池会补充⼀个新线程代替它
    特点：没有核⼼线程数等于最⼤线程数，⽆界队列作为缓冲，排队可能导致 OOM。

    ```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>());
    }
    ```

  - `newSingleThreadExecutor`

    创建只有⼀个线程的线程池对象，如果该线程出现异常⽽结束，那么线程池会补充⼀个线程
    特点： 只有⼀个线程的线程池，⽆界队列作为缓冲，排队可能导致 OOM。

    ```java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>()));
    }
    ```

  - `newScheduledThreadPool`

    创建⼀个线程池，可以实现在给定的延时后运⾏任务，或者定期执⾏任务

    ```java
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    	return new ScheduledThreadPoolExecutor(corePoolSize);
    }
    ```

    `运行阶段`

    <img src="imgs/image-20230904150235070.png" alt="image-20230904150235070" style="zoom:50%;" />

- **线程池核心参数**

  *ThreadPoolExecutor*

  ```java
  public ThreadPoolExecutor(int corePoolSize,
                           int maximumPoolSize,
                           long keepAliveTime,
                           TimeUnit unit,
                           BlockingQueue<Runnable> workQueue,
                           ThreadFactory threadFactory,
                           RejectedExecutionHandler handler)
  ```

  `corePoolSize`	线程池核心线程大小

  `maximumPoolSize` 线程池最大线程数量

  `keepAliveTime`  线程存活时间

  `unit`		  存活时间单位

  `workQueue`	 工作队列 - 4种: 基于数组、链表、不缓存、优先级的有界阻塞队列

  <img src="imgs/image-20230901192712408.png" alt="image-20230901192712408" style="zoom:50%;" />

  `threadFactory`  线程工厂 - 创建线程用的工厂, 指定线程名等

  `handler`       拒绝策略

  - AbortPolicy：处理程序遭到拒绝，则直接抛出运行时异常 RejectedExecutionException。(默认策略)
  - CallerRunsPolicy：调用者所在线程来运行该任务，此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。
  - DiscardPolicy：无法执行的任务将被删除。
  - DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重新尝试执行任务（如果再次失败，则重复此过程）。

- **扩容与缩容策略**

  线程池的扩容和缩容操作可以通过调整核心线程数和最大线程数来实现：

  - 扩容：当提交的任务数量超过核心线程数且工作队列已满时，线程池会创建新的线程来处理任务，直到达到最大线程数。可以通过适当增大核心线程数和最大线程数来提高线程池的并发能力。
  - 缩容：线程池中的线程在空闲一定时间后会被销毁，以减少资源消耗。可以通过设置合适的线程存活时间来控制线程的缩容。



### 10 线程的创建方式 | 通信方式

**创建方式**

- 继承 Thread 类, 重写 Run() 方法
- 实现 Runnable() 接口, 实现接口的 run() 方法
- 实现 Callable() 接口, 重写 call() 方法;  前两种方式线程执行完后都没有返回值，最后一种带返回值；
- 使用线程池

**通信方式**

- 共享变量: 如 volatile 修饰的变量, 可以在线程之间通信使用。
- 锁机制: Synchronized、ReentrantLock(维护的临界区变量) 等
- 条件变量: Condition 变量
- 信号量: Semaphore 类
- 管道: PipedInput|OutputStream



### 11 







## JVM

### 1 Java 内存模型 | JVM 内存模型

- Java 内存模型

  Java 内存模型是一种规范, 定义了Java程序中多线程并发访问共享内存时的行为和准则, 旨在提供一种统一的内存访问模型, 使得开发者能够编写正确、可靠而高效的多线程程序。

- JVM 内存模型

  指JVM对内存的组织和管理方式, JVM 内存模型定义了Java程序在运行时的内存结构, 包括堆、栈、方法区等。JVM内存模型规定了Java程序运行时的内存分配、使用和回收方式, 以及线程与内存的交互方式。

  主要由以下5个部分组成(运行时数据区):

  **堆**: 用于存储对象实例和数组, 是线程共享的内存区域。

  **栈**: 每个线程都有自己的栈, 用于存储方法调用、局部变量和操作数栈。

  **本地方法栈**: 用于执行本地方法的栈

  **方法区**: 存储类的结构信息、静态变量、常量池等

  **程序计数器**: 记录当前线程执行的字节码指令地址

- 特点

  - JVM 内存模型与硬件和操作系统的内存模型有一定的差异，JVM 可以在不同平台上实现统一的内存模型。
  - JVM 通过即时编译器（Just-in-Time Compiler，JIT）等技术进行代码优化和内存管理。
  - JVM 内存模型规定了对象的创建、访问、修改和销毁的方式，以及垃圾回收机制对内存的管理。



### 2 JVM 分代回收策略

Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代，这就是 JVM 的内存分代策略。注意: 在 HotSpot 中除了新生代和老年代，还有永久代。



### 3 GC 可达性分析的根节点有哪些

在Java语言中，可以作为GCRoots的对象包括下面几种：

- 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI(Native方法)引用的对象。



### 4 垃圾回收器 | 垃圾回收算法

#### 1) 垃圾回收器（Garbage Collector - GC）：

垃圾回收器是JVM中负责执行垃圾回收的组件。JVM提供了不同类型的垃圾回收器，包括：

- Serial 收集器：单线程收集器，适用于小型应用和简单的客户端应用。
- Parallel 收集器：多线程收集器，适用于多核CPU上的应用，可以并行进行垃圾回收。
- **CMS（Concurrent Mark and Sweep）收集器**：并发标记和清除收集器，避免长时间的停顿时间。 `1.9 后停用`
  1. 初始标记: 对根节点与根节点有直接关系的对象进行可达性分析并标记。
  2. 并发标记: 根据根节点标记所有可达对象。
  3. 重新标记: 更新在并发标记阶段被复活的对象。
  4. 并发清除: 并发清除所有被标记为垃圾的对象并回收内存空间。
  5. 缺点: 会产生内存碎片
- **G1（Garbage-First）收集器**：分代收集器，将堆划分为多个区域，分别进行垃圾回收。`1.9 后成为默认的回收器`
  1. 初始标记: 暂停应用线程, 对根节点与根节点有直接关系的对象进行可达性分析并标记。
  2. 并发标记: 根据根节点标记所有可达对象。
  3. 最终标记: 标记之前遗漏的对象, 线程被暂停。
  4. 筛选回收: 根据每个区域内存活的对象数量, 根据回收目标选择需要回收的区域, 然后将选中区域对象复制到空闲区, 并清理回收区域(复制算法)。
  5. 特点: 分代回收: 划分为不同的区域(新生代、老年代、存活区等); 并发执行; 更适合处理大堆内存和具有并发行性质的应用程序, 特别适用于服务器应用, 提供良好的停顿时间和吞吐量。



#### 2) 垃圾回收算法

JVM 使用不同的垃圾回收算法来标记和回收垃圾对象。常见的垃圾回收算法包括：

- 引用计数法: 对象绑定计数器, 当引用指向该对象, 计数器+1;引用被删除, 计数器-1;为0时对象被回收(等待够一批次再进行回收) 。

- 标记-清除算法（Mark and Sweep）：标记所有活动对象，然后清除未标记的对象。	`优点：垃圾回收速度快。缺点：存在内存碎片`
- 标记-整理算法（Mark and Compact）：标记活动对象，然后将它们向一端移动，然后清除其余空间。 `优点：没有内存碎片。缺点：整理速度慢`
- 复制算法（Copying）：将存活对象复制到一个新的空间，并清除旧空间中的所有对象。  `优点：没有内存碎片。缺点：内存开销大`



## Spring

> Spring 是一个轻量级的免费框架，它有两大核心功能，分别是 IOC 和 AOP ，IOC 控制反转是将创建对象的权限交给 spring 框架来控制。可以很好的起到解耦的作用。AOP 是一种编程思想以及面向切面编程，底层使用的是动态代理。可以在程序原有的功能上进行增强，常用的场景有日志记录和权限验证。

### 1 IOC | AOP

- **IOC**(控制反转)

  `将创建对象的权限交给spring`

  在之前创建对象时使用new关键字，而现在直接从spring框架中拿出已创建好的实例即可。Spring负责维护对象之间的依赖关系，降低对象之间的耦合度，它的实现方式为 DI - 依赖注入 主要的注入方式包括: 构造器、setter、接口注入。

- **AOP**(面向切面编程)

  `在方法上开一个切口，可以在这个类执行之前执行自定义的方法，在不修改源代码的前提下，对方法进行增强`
  
  AOP 面向切面编程是 spring 的两大核心之一，它是一种编程思想。。它可以对业务逻辑的各个部分进行隔离，降低耦合, 提高代码的可重用性。它的底层是通过动态代理来实现的，它主要场景包括日志记录和权限验证。 `动态代理: 实质上就是对方法加了一层代理, 然后在此之上增强它, 与静态代理的区别在于不需要一个个的实现, 而是通过反射判断是否需要代理, 需要则自动增加。`



### 2 BeanFactory 和 FactoryBean 的区别

BeanFactory 是最基础的IOC容器, 是一种规范模式; 而 FactoryBean 知识 SpringIOC 创建 Bean 的一种形式。

- beanfactory：是所有spring bean容器的顶级接口，是最基础的IOC容器，它为spring的容器定义了一套方法，并提供像getBean这样的方法从容器中获取指定的bean实例。它在产生bean的同时，还提供了解决bean之间的依赖注入的能力，也就是所谓的di。
- factory bean：工厂bean，只是SpringIOC容器创建Bean的一种形式，它是一个接口，它的主要功能是动态去生成某一类型的bean的一个实例，也就是说 我们可以自定义一个bean并且加载到ioc容器里面，getObject是用来实现动态构建bean的一个过程。



### 3 Spring 循环依赖和如何解决?

- 循环依赖

  两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。

  Spring中循环依赖场景有： 
  （1）构造器的循环依赖 
  （2）field属性的循环依赖。

  <img src="imgs/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd4dWVsZWkwMzY=,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:50%;" />

- 解决方案

  Spring 的循环依赖主要发生在属性注入阶段, 也即对 Bean对象注入实例属性的时候。当 A 属性注入需要 B, 则请求创建 B; 而 B 属性注入也需要 A, 此时就发生了类似死锁的循环依赖。

  `三级缓存` 

  ```java
  /** Cache of singleton objects: bean name to bean instance. */
  private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
  
  /** Cache of singleton factories: bean name to ObjectFactory. */
  private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
  
  /** Cache of early singleton objects: bean name to bean instance. */
  private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);
  ```

  - 一级缓存（`singletonObjects`）：缓存的是**已经实例化、属性注入、初始化后**的 Bean 对象。
  - 二级缓存（`earlySingletonObjects`）：缓存的是**实例化后，但未属性注入、初始化**的 Bean对象（用于提前暴露 Bean）。
  - 三级缓存（`singletonFactories`）：缓存的是一个 `ObjectFactory`，主要作用是生成原始对象进行 AOP 操作后的**代理对象**（这一级缓存主要用于解决 AOP 问题，后续文章中讲解）。

  采用缓存的方式, 在A依赖B时, 创建B实体, 将A与B都放入二级缓存, 这是B在依赖A时直接拿到缓存中的A使用即可。Java采用三级缓存的意义在于, Spring 的 AOP操作会在 *属性注入阶段之后* 产生代理对象, 这时二级缓存缓存的只是 *未属性注入的对象*, 这时依赖的对象与真实对象不一致则会引发问题, 所以采用了三级缓存。使用 *三级缓存* 将滞后的 `AOP` 操作提前, 避免发生依赖对象不一致的问题。  [Blog](https://juejin.cn/post/7218080360403615804)



### 4 常用注解

- `@Autowired` `@Resource` 

  **联系**

  ​	@Autowired和@Resource注解都是作为bean对象注入的时候使用的

  ​	两者都可以声明在字段和setter方法上

  **区别**

  ​	@Autowired 注解是 Spring 提供的，而 @Resource 注解是 J2EE 本身提供的
  ​	@Autowird 注解默认通过 byType 方式注入，而 @Resource 注解默认通过 byName 方式注入(不匹配则 byType)
  ​	@Autowired 注解注入的对象需要在 IOC容器中存在，否则需要加上属性 required=false ，表示忽略当前要注入的 bean，如果有直接注入，没有跳过，不会报错

 

## 应用场景

### 1 全局主键生成策略

- `数据库自增序列`

- `UUID`

  **UUID由以下几部分的组合：**    `当前时间` + `时钟序列` + `机器码`
  （1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。
  （2）时钟序列。  *“uuid的随机组件”  随机序列, 避免因一些特殊情况导致的 id 重复问题*
  （3）全局唯一的 IEEE 机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。

  ```java
  UUID uuid = UUID.randomUUID();
  ```

  **优点：**
  1）使用简单。
  2）生成ID性能高，基本不会有性能问题。
  3）全球唯一，当数据迁移、数据合并、数据库变更时，可以从容应对。

  **缺点**：
  1）数据无序，无法保证趋势递增。
  2）UUID使用字符串存储，查询效率较低。（常见优化方案为“转化为两个uint64整数存储”或者“折半存储”，折半后不能保证唯一性）
  3）存储空间较大，如果是海量数据库，需考虑存储量的问题。
  4）传输数据量大。
  5）可读性差。

- `SnowFlake 算法`

  snowflake 是 Twitter开源的分布式ID生成算法，结果是一个long型的ID。   `时间戳` + `机器码` + `序列号`

  **其核心思想是：**

  - 最高位是符号位，始终为0，不可用。
  - 41 bit 作为毫秒数 - 41位的长度可以使用69年
  - 10 bit 作为机器编号 （5个bit是数据中心，5个bit的机器ID） - 10位的长度最多支持部署1024个节点
  - 12 bit 作为毫秒内序列号 - 12位的计数顺序号支持每个节点每毫秒产生4096个ID序号

  <img src="imgs/658190-20221011092259658-771095778.png" alt="image" style="zoom:50%;" />

  算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。

  snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。

  **优点：**

  - 不依赖于数据库，速度快，性能高。
  - ID 按照时间在单机上是递增的。
  - 可以根据实际情况调整各各位段，方便灵活。

  **缺点**：

  - 在单机上是递增的，由于涉及到分布式环境，每台机器上的时钟不可能完全同步，有时也会出现不是全局递增的情况。
  - 只能趋势递增。（如果绝对递增，竞对中午下单，第二天再下单即可大概判断该公司的订单量，危险！）
  - 依赖机器时间，如果发生回拨会导致可能生成id重复。



### 2 限流算法

- 令牌桶算法：

  - 原理：令牌桶算法通过维护一个固定容量的令牌桶，以固定的速率往桶中放入令牌。每个令牌代表一个请求或事件，桶中的令牌数量表示当前可处理的请求数量。当请求到达时，需要从令牌桶中获取一个令牌才能进行处理。如果桶中没有足够的令牌，则请求将被延迟或丢弃。

  - 应用场景：令牌桶算法适用于对 `请求` 进行限流的场景，可以控制单位时间内的请求速率，确保系统在高负载或突发请求情况下仍能保持稳定。

- 漏斗算法：

  - 原理：漏斗算法通过模拟一个漏斗的行为来控制请求的处理速率。漏斗具有一个固定的容量，以固定的速率流出。每个请求代表一定量的水，当请求到达时，如果漏斗有足够的容量，则可以处理该请求，漏斗容量减少；如果漏斗已满，则请求将被延迟或丢弃。

  - 应用场景：漏斗算法适用于对 `任务处理` 进行限流的场景，可以平滑请求的处理速率，防止突发请求对系统造成过大的压力。

- 区别：

  - 令牌桶算法是通过固定速率放入令牌，然后按需获取令牌来控制请求速率，而漏斗算法是通过固定速率流出来控制请求速率。

  - 令牌桶算法可以在固定的速率下处理请求，而漏斗算法可以适应突发请求，根据漏斗的容量来动态调整请求的处理速率。

  - 令牌桶算法的令牌可以积累一段时间，允许一定程度的突发请求，而漏斗算法是根据漏斗的固定容量来限制请求的处理速率。

  - 令牌桶算法对于请求速率的限制更加精确，可以精确控制每个请求的处理时间间隔，而漏斗算法更侧重于平滑请求的处理速率，对于突发请求的处理更具弹性。



### 3 Java 常见加密解密算法

- `Base64`

  用 64 个可打印字符来表示二进制数据。这 64 个字符是：小写字母 a-z、大写字母 A-Z、数字 0-9、符号"+"、"/"（再加上作为垫字的"="，实际上是 65 个字符），其他所有符号都转换成这个字符集中的字符。Base64 编码通常用作存储、传输一些二进制数据编码方法，所以说它本质上是一种将二进制数据转成文本数据的方案。

- `哈希加密`

  - MD5（Message Digest Algorithm 5）

    MD5 主要用做数据一致性验证、数字签名和安全访问认证，而不是用作加密。比如说用户在某个网站注册账户时，输入的密码一般经过 MD5 编码，更安全的做法还会加一层盐（salt），这样密码就具有不可逆性。然后把编码后的密码存入数据库，下次登录的时候把密码 MD5 编码，然后和数据库中的作对比，这样就提升了用户账户的安全性。生成128位散列值，常用于校验数据完整性。   `单向加密算法，只能加密不能解密`

  - bcrypt

    bcrypt 是一种自带盐值（自动加盐）的加密方案。 

    *加密* : 随机生成 salt -> salt; 跟 password 进行 hash

    *解密* : 从 hash 中取出salt -> salt跟 password 进行hash计算 -> 将得到的 hash 跟数据库中提取的的hash进行比对返回Boolean类型：true/false

    |    **项**    |                           **md5**                            |                          **bcrypt**                          |
    | :----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
    | **密文长度** |                             32位                             |                             60位                             |
    |  **安全性**  | 安全性差。密码相同时，加密后密文一样。提升安全性的方案：加密前生成随机的盐值（字符串），将它与密码拼接，然后再使用md5加密。 | 安全性好。密码相同时，生成的密文是不一样的。（因为它自动生成随机盐值） |
    | **加密耗时** |                              短                              |                             略长                             |

  - SHA（Secure Hash Algorithm - 安全散列算法）

    FIPS所认证的安全散列算法。能计算出一个数字消息所对应的长度固定字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。数字签名等密码学应用中重要的工具，被广泛地应用于电子商务等信息安全领域。 SHA-1、SHA-256、SHA-512 等散列算法，生成不同长度的散列值。

- `非对称加密`

  - RSA（Rivest-Shamir-Adleman）

    非对称加密算法，用于实现公钥加密和数字签名。RSA使用公钥进行加密，私钥进行解密或签名。生成密钥对、公开公钥、公钥加密私钥解密、私钥加密公钥解密。

  - DSA（Digital Signature Algorithm）

    数字签名算法，用于生成和验证数字签名。

- `对称加密`

  - AES（Advanced Encryption Standard）

    目前最常用的对称加密算法之一，支持 128 位、192 位和 256 位密钥长度。密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。简单说就是 DES 的增强版，比 DES 的加密强度更高。

  - DES（Data Encryption Standard）

    DES 是一种对称加密算法，所谓对称加密算法就是：加密和解密使用相同密钥的算法。DES 加密算法出自 IBM 的研究，后来被美国政府正式采用，之后开始广泛流传。但近些年使用越来越少，因为 DES 使用 56 位密钥，以现代的计算能力，24 小时内即可被破解。

  - 3DES（Triple Data Encryption Algorithm）

    对DES进行了三重加密，提供更高的安全性。

- `对称加密和非对称加密的区别`

  对称加密：

  - 使用相同的密钥进行加密和解密操作，因此也称为共享密钥加密。
  - 加密速度较快，适合处理大量数据。
  - 密钥管理相对简单，只需保护好密钥的安全性。
  - 主要用于数据加密和解密，不适用于身份验证和数字签名。
  - 常见的对称加密算法有 AES、DES、3DES 等。

  非对称加密：

  - 使用一对密钥，即公钥和私钥，进行加密和解密操作，因此也称为公钥加密。
  - 公钥用于加密数据，私钥用于解密数据，公钥可以公开分发，私钥保密。
  - 加密速度较慢，适合处理较小的数据量。
  - 可用于身份验证、数字签名和密钥交换等场景。
  - 常见的非对称加密算法有RSA、DSA等。

  对称加密和非对称加密的主要区别如下：

  - 密钥数量：对称加密使用相同的密钥进行加密和解密，而非对称加密使用一对不同的密钥。
  - 加密速度：对称加密算法加密和解密速度较快，而非对称加密算法加密和解密速度较慢。
  - 安全性：对称加密的主要安全性依赖于密钥的保护，而非对称加密的安全性依赖于私钥的保密性。
  - 用途：对称加密主要用于数据加密和解密，而非对称加密可以用于身份验证、数字签名和密钥交换等场景。















## 诺瓦

### 1 说说你对面向对象的理解

面向对象有三大基础特征: 封装、继承、多态。

封装: 将对象的状态信息隐藏起来, 不允许外界直接访问, 只能通过暴露的接口进行操作访问, 提高代码可维护性; 

继承: 实现代码复用的手段, 能够通过 extends 关键字继承父类的属性和方法; 

多态: 依赖于继承, 子类可以选择重写父类方法, 也可选择直接调用父类方法实现功能的复用与拓展。



### 2 封装 | 继承 | 多态

- **封装**

  `将数据和操作结合为一个不可分割的整体, 隐藏对象属性和细节, 只提供对外接口。使用者无需了解细节, 只需通过外部接口即可访问和完成操作。`

  - private: 只能被当前类内部访问
  - default: 只能被当前类和其所在包的其他类访问
  - protected: 只能被当前类和其所在包的其他类以及子类访问。
  - public: 可以被当前项目中的所有类访问

  ![img](imgs/274e6b8cc40c4c66ad93056fe6c5991b.png)

- **继承**

  `子类继承父类, 让子类对象具有父类对象的属性、方法和行为`

  Animal <- Dog   <- Cat

- **多态**

  `同一个行为具有多个不同表现形式或形态的能力`

  现实生活中，同一个方法，具体实现会完全不同。 比如：同样是调用人的"休息"方法，张三是睡觉，李四是旅游，王五是听音乐； 同样是调用人“吃饭”的方法，中国人用筷子吃饭，英国人用刀叉吃饭，印度人用手吃饭。

  1. 多态是方法的多态，不是属性的多态（多态与属性无关）。

  2. 多态的存在要有 3 个必要条件：继承，方法重写，父类引用指向子类对象。

  3. 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。

     使用父类做方法的形参和返回值，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，符合开闭原则。

  **重载和重写的区别 | 构造方法能不能重写**

  - 重写 `override` 

    在父子类中发生, 用于方法的拓展, 方法与参数都相同; 

  - 重载 `overload`

    在类中发生, 方法名相同参数不同。构造方法无法重写, 重写要求类名一致, 而父类和子类的构造方法名不一致, 因此无法重写。



### 3 Java 类中的变量、方法、对象的保存位置

- `局部变量` - *栈*
- `成员变量、对象和对象数组` - *堆*
- `本地方法` - *本地方法栈*  本地方法: 就是一个为了提供C/C++程序功能的接口, 声明为 Java 的 Native Method, 但是实现是其它语言。
- `字段、方法、修饰符` - *方法区*
- `常量` - *常量池*



### 4 Map

- **HashMap**

  - 底层

    - Beafor 1.8: 数组 + 链表
    - After 1.8:  数组 + 链表 + 红黑树

  - PUT流程: 通过计算存入 KEY 的 Hash 值确定存入位置, 如果当前位置存在数据也即发生碰撞则通过链表接在一起, 当链表长度达到 8 时则转为红黑树存放, 以此提高查询效率。

  - 扩容机制

    HashMap 数组初始容量为 16, 达到默认装载因子 0.75 时会触发 2 倍扩容。

  - HashMap 非线程安全, 建议在多线程并发下使用 ConcurrentHashMap 

    **ConcurrentHashMap**

    - `ConcurrentHashMap` 的底层数据结构与 HashMap 一样, 也是采用“数组+链表+红黑树 

    - 采用锁定头节点的方式降低了锁粒度, 以较低的性能代价实现了线程安全。 

    - 实现机制(*锁定头结点*)

      初始化数组或头节点时, ConcurrentHashMap并没有加锁, 而是以 CAS 的方式进行原子替换 

      插入数据时会进行加锁处理, 但锁定的不是整个数组, 而是槽中的头节点。所以, ConcurrentHashMap 中锁的粒度是槽, 而不是整个数组,并发的性能很好。

      扩容时会进行加锁处理, 锁定的仍然是头节点。并且, 支持多个线程同时对数组扩容, 提高并发能力。 

      在扩容的过程中,依然可以支持查找操作。

  *HashMap 线程安全的吗？如果不是该如何解决？*

  - 使用 HashTable 效率低
  - 使用 Collection 下的 synchronizedXX() 方法包装 HashMap
  - 使用 ConcurrentHashMap 

- **HashTable**

  - **区别**
    - HashTable 线程安全, HashMap 非线程安全, 性能 HashMap 比较好
    - HashTable 不允许 NULL 存入, HashMap 允许为 NULL。
    - HashTable 数组 + 链表, HashMap 数组 + 链表/红黑树

- **TreeMap**

  `基于红黑树实现` `按 Key 顺序或 Comparator 顺序有序` `不允许重复` `动态扩容`    *效率低于HashMap, 一般在需要排序的情况下使用*

- **LinkedHashMap**

  `插入顺序有序` `基于双向链表实现`



### 5 Set

- **HashSet**

  `无序` `元素值允许为NULL` `不允许重复` `非线程安全` `基于HashMap实现` `JDK8之前，数组+链表;  JDK8以后，数组+链表+红黑树 - 扩容原则与 HashMap 一致`

  - 保证不重复

    使用 `hashCode` 与 `equals` 方法检测重复。一个元素, 使用 `hashCode` 判断该元素key值是否存在, 已存在则不添加; 不存在再调用 `equals` 方法判断结果, 如果依旧一样则不添加, 不一样则添加到 Set 集合。

- **TreeSet**

  `基于TreeMap实现` `有序且不重复` ``





### 6 进程和线程的状态有哪些

- 进程的状态: `创建`、`就绪`、`运行`、`阻塞`、`销毁`

  new 一个线程时为创建状态, 执行 start() 方法后为就绪状态, 当线程获取CPU资源后执行 run() 进入运行状态, 调用 sleep() 进入阻塞状态, 进程执行完或抛出异常进入销毁状态。

- 线程的状态: Java线程一共有6种状态。

  `NEW`: 初始状态，还没调用 start 方法。

  `Runnable`: 运行状态，线程正在JVM中执行，也可能在等待操作系统的调度。

  `BLOCKED`：阻塞状态，线程正在等待获取监视器锁。

  `WAITING`: 等待状态，线程正在等待其他线程的通知或中断。

  `TIMED_WAITING`: 超时等待状态，在WAITING的基础上增加了超时时间，即超出时间自动返回。

  `TERMINATED`：终止状态，线程已执行完毕。 



### 7 Spring Boot 常用注解

`@SpringbootAplication`: 程序入口 - 开启自动配置

`@EnableautoConfiguration`: 开启自动配置 - 自动配置程序运行所需的功能和组件

`@ComponentScan`: 用于扫描指定的包和组件

`@Import`: 导入依赖  @Conditional   @Unconditional 等



### 8 数据库连接语法

- LEFT JOIN  取左表全部, 右表没有的为 NULL

- RIGHT JOIN  取右表全部, 左表没有的为 NULL

- INNER JOIN   取两表交集

- FULL JOIN    取两表并集(MYSQL没有)

- **LEFT | RIGHT JOIN 查询慢的优化方法?**

  `采用小表驱动大表` - A * JOIN B, A 为小表, B 为大表

  `使用慢SQL分析 - EXPLAIN 分析执行计划和索引情况, PROFILE 分析资源使用情况, OPTIMIZER TRACE 分析数据库语句具体执行情况  `





