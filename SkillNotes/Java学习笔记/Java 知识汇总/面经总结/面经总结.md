## I Java 面试真题一

### 1 请你说说Java的特点和优点,为什么要选择Java？

Java 语言的特点: 一次编译, 到处运行, 即平台无关性, 是一种纯面向对象的语言。

优点: 内置的很多库函数简化了开发人员的设计工作; 具有较高的安全性和健壮性; 有较好的生态支持; 开发人员不需要对内存使用进行管理。

选择 Java 的原因: 使用范围很广, 包括 - web、大数据、安卓等, 生态与 API 支持很完备。



### 2 请你说说 Java 基本数据类型和引用类型

Java 语言提供了8种基本类型: byte 8、short 16、int 32、long 64、float 32、double 64、char 16、boolean (不同JVM大小不同), 这些基本数据类型有对应的封装类; 这些基本数据类型在声明之后就会立刻在栈上被分配内存空间。其他数据类型如: 数组、类、接口、String 等在生命时不会被立即分配内存, 知识存储了内存地址。



### 3 请你说一下抽象类和接口的区别

相同点: 两者都不能被实例化; 都可以拥有抽象方法;

区别: 抽象类定义关键字为 abstract class、接口为 interface; 抽象类可以有静态变量、成员变量和常量, 接口只能有常量; 接口需要实现implement，抽象类只能被继承extends，一个类可以实现多个接口，但一个类只能继承一个抽象类; 抽象类中的方法不必都是抽象的，但是接口中的方法都是抽象的;  抽象类倾向于充当公共类的角色，当功能需要累积时，用抽象类；接口被运用于实现比较常用的功能，功能不需要累积时，用接口; 一个类只能单继承一个父类，而一个接口可以继承多个父接口，同时，一个类可以实现多个接口却没有实现多个父类这一说法；



### 4 请你说一下final关键字

final 可以修饰类、方法、变量; final 修饰类, 该类不可被继承; final 修饰方法, 该方法不能被重写; final 修饰变量, 基本类型值不可改变, 引用类型值可变地址不可变; 



### 5 说说static修饰符的用法

Java类中包含: 成员变量、方法、构造器、初始化块和内部类（包括接口、枚举）5种成员。

`static` 关键字可以修饰除了构造器外的其他4种成员。

静态方法只能访问用 `static` 修饰的成员 

1. 修饰方法与成员变量  

   static修饰的变量是存储于方法区的, 表示类方法或者类成员变量，是所有对象所共享的。可以通过类名调用，也可以通过实例对象调用。 

2. 静态代码块:

   当类被加载时，静态代码块会执行一次，因为一个类只加载一次，所以静态代码块只执行一次。通常使用静态代码块对类的成员变量进行初始化。 

3. 修饰内部类 

   可以在不创建外部类对象的情况下被实例化。



### 6 请你说说String类, 以及使用 new 和 字符串常量 创建String的区别

String 类由 `final` 修饰, 所以它不可被继承。使用 String直接量方式赋值时, 字符串被保存到常量池; 使用 `new` 关键字创建字符串时, 会先使用常量池管理字符串直接量, 然后新创建一个 String 对象放在堆中, 比较耗内存。



### 7 String、StringBuffer、Stringbuilder有什么区别

Java 提供了 String、StringBuffer 两个类和大量的方法来封装字符串。String 被创建后不可变、效率低, 但复用率高; StringBuffer 创建后可变、效率高, 线程安全; StringBuilder 也可变、效率最高, 但线程不安全; 因此,如果是在单线程下操作大量数据,应优先使用 StringBuilder类；如果是在多线程下操作大量数据,应优先使用 StringBuffer 类。



### 8 请你说说 == 与 equals() 的区别

`==` 比较基本类型时比较值是否相等, 引用类型则比较地址是否相等; `equals()` 没有重写之前与 `==` 一致, 重写后可使用 按值比较。



### 9 请你说说 hashCode() 和 equals() 的区别,为什么重写 equals() 就要重写 hashCode()

`hashCode` 用于获取哈希值, `equals()` 用于比较对象是否相等; 如果两个对象相等, 它们必须有相同的哈希码；若两个对象的哈希码相同,他们却不一定相等。也就是说, equals() 比较两个对象相等时 hashCode() 一定相等, hashCode() 相等的两个对象 equqls() 不一定相等; 由于hashCode() 与 equals() 具有联动关系, equals() 重写时, hashCode() 进行重写, 使得这两个方法始终满足相关的约定。



### 10 请你讲一下Java 8的新特性

**Lambda 表达式** − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。   

**方法引用** − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。   

**对接口进行了改进**：允许在接口中定义默认方法,默认方法必须使用default修饰。  

**新工具** − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。   

**Stream API** −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。   

**Date Time API** − 加强对日期与时间的处理。   

**Optional 类** − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。   

**Nashorn, JavaScript 引擎** − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。



### 11 介绍一下包装类的自动拆装箱与自动装箱

自动装箱和拆箱时 JDK 1.5 提供的功能; 自动装箱: 将基本类型赋值给对应的包装类型。 自动拆箱: 将包装类型对象赋值给基本类型。通过自动装箱、自动拆箱功能,简化基本类型变量和包装类对象之间的转换过程。

| 基本数据类型 | 对应包装类 |
| ------------ | ---------- |
| byte         | Byte       |
| short        | Short      |
| int          | Integer    |
| long         | Long       |
| float        | Float      |
| double       | Double     |
| char         | Character  |
| boolean      | Boolean    |



### 12 请你说说Java的异常处理机制

*try中写业务代码，catch用于捕获并处理某个异常，finally用于回收资源, throw主动抛出异常*

1. 异常处理机制让程序具有容错性和健壮性, 程序运行出现状况时,系统会生成一个Exception对象来通知程序 
2. 处理异常的语句由try、catch、finally三部分组成。try块用于包裹业务代码,catch块用于捕获并处理某个类型的异常,finally块则用于回收资源。 
3. 如果业务代码发生异常,系统创建一个异常对象, 并将其提交给JVM, 由JVM寻找可以处理这个异常的 catch 块,并将异常对象交给这个catch块处理。如果JVM没有找到，运行环境终止, Java程序退出。 
4. Java也允许程序主动抛出异常。当业务代码中,判断某项错误的条件成立时,可以使用throw关键字向外抛出异常。



