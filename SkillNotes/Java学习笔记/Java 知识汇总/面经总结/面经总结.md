## I Java 面试真题一

### 1 请你说说Java的特点和优点,为什么要选择Java？

Java 语言的特点: 一次编译, 到处运行, 即平台无关性, 是一种纯面向对象的语言。

优点: 内置的很多库函数简化了开发人员的设计工作; 具有较高的安全性和健壮性; 有较好的生态支持; 开发人员不需要对内存使用进行管理。

选择 Java 的原因: 使用范围很广, 包括 - web、大数据、安卓等, 生态与 API 支持很完备。



### 2 请你说说 Java 基本数据类型和引用类型

Java 语言提供了8种基本类型: byte 8、short 16、int 32、long 64、float 32、double 64、char 16、boolean (不同JVM大小不同), 这些基本数据类型有对应的封装类; 这些基本数据类型在声明之后就会立刻在栈上被分配内存空间。其他数据类型如: 数组、类、接口、String 等在生命时不会被立即分配内存, 知识存储了内存地址。



### 3 请你说一下抽象类和接口的区别

相同点: 两者都不能被实例化; 都可以拥有抽象方法;

区别: 抽象类定义关键字为 abstract class、接口为 interface; 抽象类可以有静态变量、成员变量和常量, 接口只能有常量; 接口需要实现implement，抽象类只能被继承extends，一个类可以实现多个接口，但一个类只能继承一个抽象类; 抽象类中的方法不必都是抽象的，但是接口中的方法都是抽象的;  抽象类倾向于充当公共类的角色，当功能需要累积时，用抽象类；接口被运用于实现比较常用的功能，功能不需要累积时，用接口; 一个类只能单继承一个父类，而一个接口可以继承多个父接口，同时，一个类可以实现多个接口却没有实现多个父类这一说法；



### 4 请你说一下final关键字

final 可以修饰类、方法、变量; final 修饰类, 该类不可被继承; final 修饰方法, 该方法不能被重写; final 修饰变量, 基本类型值不可改变, 引用类型值可变地址不可变; 



### 5 说说static修饰符的用法

Java类中包含: 成员变量、方法、构造器、初始化块和内部类（包括接口、枚举）5种成员。

`static` 关键字可以修饰除了构造器外的其他4种成员。

静态方法只能访问用 `static` 修饰的成员 

1. 修饰方法与成员变量  

   static修饰的变量是存储于方法区的, 表示类方法或者类成员变量，是所有对象所共享的。可以通过类名调用，也可以通过实例对象调用。 

2. 静态代码块:

   当类被加载时，静态代码块会执行一次，因为一个类只加载一次，所以静态代码块只执行一次。通常使用静态代码块对类的成员变量进行初始化。 

3. 修饰内部类 

   可以在不创建外部类对象的情况下被实例化。



### 6 请你说说String类, 以及使用 new 和 字符串常量 创建String的区别

String 类由 `final` 修饰, 所以它不可被继承。使用 String直接量方式赋值时, 字符串被保存到常量池; 使用 `new` 关键字创建字符串时, 会先使用常量池管理字符串直接量, 然后新创建一个 String 对象放在堆中, 比较耗内存。



### 7 String、StringBuffer、Stringbuilder有什么区别

Java 提供了 String、StringBuffer 两个类和大量的方法来封装字符串。String 被创建后不可变、效率低, 但复用率高; StringBuffer 创建后可变、效率高, 线程安全; StringBuilder 也可变、效率最高, 但线程不安全; 因此,如果是在单线程下操作大量数据,应优先使用 StringBuilder类；如果是在多线程下操作大量数据,应优先使用 StringBuffer 类。



### 8 请你说说 == 与 equals() 的区别

`==` 比较基本类型时比较值是否相等, 引用类型则比较地址是否相等; `equals()` 没有重写之前与 `==` 一致, 重写后可使用 按值比较。



### 9 请你说说 hashCode() 和 equals() 的区别,为什么重写 equals() 就要重写 hashCode()

`hashCode` 用于获取哈希值, `equals()` 用于比较对象是否相等; 如果两个对象相等, 它们必须有相同的哈希码；若两个对象的哈希码相同,他们却不一定相等。也就是说, equals() 比较两个对象相等时 hashCode() 一定相等, hashCode() 相等的两个对象 equqls() 不一定相等; 由于hashCode() 与 equals() 具有联动关系, equals() 重写时, hashCode() 进行重写, 使得这两个方法始终满足相关的约定。



### 10 请你讲一下Java 8的新特性

**Lambda 表达式** − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。   

**方法引用** − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。   

**对接口进行了改进**：允许在接口中定义默认方法,默认方法必须使用default修饰。  

**新工具** − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。   

**Stream API** −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。   

**Date Time API** − 加强对日期与时间的处理。   

**Optional 类** − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。   

**Nashorn, JavaScript 引擎** − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。



### 11 介绍一下包装类的自动拆装箱与自动装箱

自动装箱和拆箱时 JDK 1.5 提供的功能; 自动装箱: 将基本类型赋值给对应的包装类型。 自动拆箱: 将包装类型对象赋值给基本类型。通过自动装箱、自动拆箱功能,简化基本类型变量和包装类对象之间的转换过程。

| 基本数据类型 | 对应包装类 |
| ------------ | ---------- |
| byte         | Byte       |
| short        | Short      |
| int          | Integer    |
| long         | Long       |
| float        | Float      |
| double       | Double     |
| char         | Character  |
| boolean      | Boolean    |



### 12 请你说说Java的异常处理机制

*try中写业务代码，catch用于捕获并处理某个异常，finally用于回收资源, throw主动抛出异常*

1. 异常处理机制让程序具有容错性和健壮性, 程序运行出现状况时,系统会生成一个Exception对象来通知程序 
2. 处理异常的语句由try、catch、finally三部分组成。try块用于包裹业务代码,catch块用于捕获并处理某个类型的异常,finally块则用于回收资源。 
3. 如果业务代码发生异常,系统创建一个异常对象, 并将其提交给JVM, 由JVM寻找可以处理这个异常的 catch 块,并将异常对象交给这个catch块处理。如果JVM没有找到，运行环境终止, Java程序退出。 
4. Java也允许程序主动抛出异常。当业务代码中,判断某项错误的条件成立时,可以使用throw关键字向外抛出异常。



### 13 说说你对面向对象的理解

面向对象有三大基础特征: 封装、继承、多态。封装: 将对象的状态信息隐藏起来, 不允许外界直接访问, 只能通过暴露的接口进行操作访问, 提高代码可维护性; 继承: 实现代码复用的手段, 能够通过 extends 关键字继承父类的属性和方法; 多态: 依赖于继承, 子类可以选择重写父类方法, 也可选择直接调用父类方法实现功能的复用与拓展。



### 14 请你说说重载和重写的区别,构造方法能不能重写

重写在父子类中发生, 用于方法的拓展, 方法与参数都相同; 重载在类中发生, 方法名相同参数不同。构造方法无法重写, 重写要求类名一致, 而父类和子类的构造方法名不一致, 因此无法重写。



### 15 请介绍一下访问修饰符

Java 的访问修饰符: private protected public default。

private: 只能被当前类内部访问

default: 只能被当前类和其所在包的其他类访问

protected: 只能被当前类和其所在包的其他类以及子类访问。

public: 可以被当前项目中的所有类访问



### 16 请你说说泛型、泛型擦除

JDK1.5 之后引入泛型, 泛型可以为类型指定参数, 减少了插入对象的类型出错问题, 所有强制转换都是自动且隐藏的提高了代码的复用率。泛型擦除: Java 的泛型是伪泛型, 因此编译器在编译期间需要在进行擦除, 然后进行类型转换。



### 17 请说说你对反射的了解

反射就是在程序运行期间动态获取对象属性和方法的功能, 其使用基于class对象来处理, 它能够在程序运行期间直接获取任意类的方法和属性, 大大提高了代码的可扩展性, 但是同时破坏了 JAVA 的特性, 会引起一系列的安全问题, 同时降低程序的新梗。



### 18 请你说说多线程

进程是操作系统资源调度的最小单位, 线程是处理器任务调度和执行的基本单位, 一个进程可以创建多个线程。多个线程之间共享程序的内存空间和系统资源, 但都有自己的独立栈空间。多线程可以减小程序的响应时间,提高CPU利用率,创建和切换开销小,数据共享效率高,简化程序结构。



### 19 线程的创建方式

- 继承 Thread 类, 重写 Run() 方法
- 实现 Runnable() 接口, 实现接口的 run() 方法
- 实现 Callable() 接口, 重写 call() 方法;  前两种方式线程执行完后都没有返回值，最后一种带返回值；
- 使用线程池



### 20 说说进程和线程的状态

- 进程的状态: 创建、就绪、运行、阻塞、销毁。 new 一个线程时为创建状态, 执行 start() 方法后为就绪状态, 当线程获取CPU资源后执行 run() 进入运行状态, 调用 sleep() 进入阻塞状态, 进程执行完或抛出异常进入销毁状态。

- 线程的状态: Java线程一共有6种状态。`NEW` 初始状态，还没调用 start 方法。`Runnable` 运行状态，线程正在JVM中执行，也可能在等待操作系统的调度。 `BLOCKED`：阻塞状态，线程正在等待获取监视器锁。 `WAITING`: 等待状态，线程正在等待其他线程的通知或中断。`TIMED_WAITING`: 超时等待状态，在WAITING的基础上增加了超时时间，即超出时间自动返回。 `TERMINATED`：终止状态，线程已执行完毕。 



### 21 说说wait()和sleep()的区别

所属类型不同: wait() 为Object类的实例方法, 调用后进入WAITING状态; sleep() 属于 Thread 类的静态方法, 调用后进入 TIMED_WAITING 状态。

锁依赖不同: wait() 依赖于 synchronized 锁, 调用后线程会释放锁; sleep() 不依赖锁, 也不会释放锁。

返回条件不同: wait() 进入等待状态, 使用 notify() | notifyAll() 唤醒; sleep() 进入超时等待, 需要超时后自动返回。



### 22 如何保证线程安全

CAS的全称是 Compare-and-Swap，也就是比较并交换，是并发编程中一种常用的算法。它包含了三个参数：V，A，B。其中，V表示要读写的内存位置，A表示旧的预期值，B表示新值。`CAS` 的核心思想是：在执行操作之前，先比较当前内存中的值是否等于期望值，如果相等，则执行修改操作；如果不相等，则不执行修改操作，继续进行比较，直到内存中的值与期望值相等为止。这个过程中不会出现线程的阻塞和唤醒，因此可以提高系统的并发性能。 CAS操作需要输人两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。

三种方案: 原子类、volatile、锁

- 原子类: 遵循 CAS - '比较和替换' 原则, 如果要更新的旧值与线程传入的旧值不一样, 则认为被其他线程修改, 修改不生效。

- volatile 关键字: 轻量级的 sychronized, 在多处理器开发中保证共享变量的可见性, 从而保证单个变量读写的线程安全。

  volatile 禁止指令重排序(添加屏障)

  写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下
  读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上

- sychronized 关键字: synchronized+juc包下的lock锁。支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量



### 23 说说你了解的线程同步方式

Java 通过加锁实现线程同步: synchronized 和 Lock。 synchronized 加在普通方法上, 锁当前实例;加在静态方法, 锁当前类的从class对象;加在代码块上, 则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。 Lock 支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。



### 24 说说你了解的线程通信方式

线程通信: monitor 与 condition。 Synchronized 采用 monitor 的通信方式, 线程通过 monitor 调用 wait() 进入等待, 调用 notify() | notifyAll() 唤醒进程。 Lock 采用 condition 通信, 使用 await() 进入等待, 使用 signal()|signalAll() 唤醒线程。



### 25 Java 常用的锁和原理

常用锁包括 Synchronized 和 Lock 锁, Synchronized 通过Java对象头存储锁信息, Lock 则基于AQS实现。



### 26 说说你对AQS的理解

AQS 队列同步器: 用来构建锁和同步器的框架, 原理为维护共享资源, 使用队列让线程进行排队的过程, Lock 基于其实现。

AQS 内部定义 先进先出 队列实现线程同步, 同时定义同步状态记录锁信息。



### 27 synchronized和Lock有什么区别

synchronized 是关键字, Lock 是接口。Lock 加锁不会自动释放, synchronized  可以自动释放。 Lock 可以通过 tryLock() 判断加锁状态, synchronized 不可以。

synchronize的用法及原理:

​	synchronized 可以修饰静态方法、代码块、普通方法。它能够保证同一时间只有一个线程执行该代码, 保证线程安全。它能够在执行完毕或出现异常后自动释放锁。底层是采用Java对象头来存储锁信息的,并且还支持锁升级。在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步。synchronized 加在普通方法上, 锁当前实例;加在静态方法, 锁当前类的从class对象;加在代码块上, 则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。



### 28 说说你对线程池的理解

线程池：主要起到管理线程作用, 可以有效的管理线程: 线程数量、线程复用。线程池的好处：1.更方便管理线程 2.可以减少因频繁创建线程和销毁线程带来的内存消耗，提高程序的运行效率。  1）它可以管理线程的数量，可以避免无节制的创建线程，导致超出系统负荷直至奔溃。2）它还可以让线程复用，可以大大地减少创建和销毁线程所带来的开销。



### 29 volatile 的用法及原理

`volatile是一个Java的关键字，用来解决内存可见性问题的。它能够保证线程之间可见, 通过添加屏障的方式避免指令重排序导致的线程安全问题。`

- 保证线程之间的可见性

  volatile 关闭 JIT(即时编译器) 对其所修饰变量的优化(多线程并发的情况下, JIT 优化有时候会导致非预期的结果)

- 禁止指令重排序

  volatile 禁止指令重排序(添加屏障)

  写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下
  读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上

  volatile使用技巧:

  - 写变量让volatile修饰的变量的在代码最后位置
  - 读变量让volatile修饰的变量的在代码最开始位置



### 30 说说你对ThreadLocal的理解
